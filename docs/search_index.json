[["index.html", "R Course Chapter 1 R Course", " R Course YOUR NAME HERE 2024-05-09 Chapter 1 R Course "],["r---introduction.html", "Chapter 2 R - Introduction 2.1 R - Basic Concepts and applications 2.2 Why R? 2.3 R studio 2.4 Basic Mathematics like operators 2.5 R Markdown 2.6 Installation of packages", " Chapter 2 R - Introduction 2.1 R - Basic Concepts and applications R (programming language) is a language and environment for statistical computing and graphics 2.2 Why R? Developed by Statisticians - R is Excellent for Statistical Computing and Analysis Open-source (Free) - R is an open-source programming language. Anyone can work with R without any license or fee. Due to this, R has a huge community that contributes to its environment. A Large Variety of Specialized Libraries - These libraries support and enhance the R development environment. R Studio - A graphic user interface to R - easier to grasp and learn. Cross-platform Support - R is machine-independent. It supports the cross-platform operation. Thus, it is usable on many different operating systems. Can do Data Cleansing, Data Wrangling, and Web Scraping - R can collect data from the internet through web scraping and other means. It can also perform data cleansing. R is also useful for data wrangling which is the process of converting raw data into the desired format for easier consumption. Powerful Graphics - R has extensive libraries that can produce production quality graphs and visualizations. Compatible with other Programming Languages - R is compatible with other languages like C, C++, and FORTRAN. Other languages like .NET, Java, Python can also directly manipulate objects. Compatible with high performance computing and Big Data Analytics. 2.3 R studio Rstudio is an integrated development environment(IDE) for R. It includes a console, syntax-highlighting editor that supports direct code execution as well as tools for plotting history, debugging and work space management. RStudio - installation link &lt;-link in the first 7 minutes-&gt; Outline the process of creating and running R script - a screenshot &lt;–Check R Version –&gt; 2.3.1 R - Look and Feel The image above is for R code in R Studio. Each quadrant has its own function. - text editor serves as the primary interface for writing and editing R scripts, Markdown documents, and other text-based files stand input/output (console/terminal/jobs) It is the bottom left quadrant in R Studio that serves as a command-line interface where you can directly interact with R such as code execution and output display. all data and its properties quadrants It is the top right quadrant in Rstudio that is typically the “Environment” pane, which provides information and tools for managing your R environment such as data importation, display of variables. plots and file directory structure The bottom right quadrant in RStudio typically houses the “Files”, “Plots”, “Packages”, “Help”, and “Viewer” tabs. 2.4 Basic Mathematics like operators Addition - the + operator is used to add two or more values 2+3 ## [1] 5 Subtraction - the - operator is used to subtract two numerical values 6-2 ## [1] 4 2.5 R Markdown R Markdown is a versatile markup language that allows you to create dynamic documents that integrate text, code, and output. It is widely used in data analysis, scientific research, and reporting The figure shows how markdown looks like Each chunk can be run separately in a single file, also the variable in one chunk can be reused by the next/later chunks Anything added outside the chuck will not be executed in the program The R markdown can be knitted to a html, pdf, or word file and presented to the audience 2.6 Installation of packages R libraries/packages can be installed by invoking install.packages(\"package_name\") to the console. The figure below shows how to install expn library. "],["data-types-and-data-structures.html", "Chapter 3 Data Types and Data Structures 3.1 Data types 3.2 Data Structures", " Chapter 3 Data Types and Data Structures 3.1 Data types There are different kinds of values in R that can be manipulated in variables in R. class()function is used to check the data type of a value or a variable. Different data types include; Numeric These represent numeric values such as integers and decimals. They are used for mathematical expressions and quantitative data analysis. Example: a=23.5 class(a) #check the data type of a ## [1] &quot;numeric&quot; a whole number without without a decimal is also numeric for instance 45, 8, 0 and 73. class(45) ## [1] &quot;numeric&quot; class(8) ## [1] &quot;numeric&quot; class(0) ## [1] &quot;numeric&quot; class(73) ## [1] &quot;numeric&quot; Integers They represent whole numbers without any any decimals and are a subclass of numeric. L is added at the end of a whole number to indicate that it is an integer. a=23L #add L to show it is an integer class(a) ## [1] &quot;integer&quot; Lets store age as an integer age = 27L class(age) ## [1] &quot;integer&quot; Characters They represent text strings such as names, sentences and labels. They are enclosed in ” or ’. a=&quot;DNA&quot; class(a) ## [1] &quot;character&quot; Lets use name as a character name = &quot;Pragya&quot; class(name) ## [1] &quot;character&quot; for an object item = &quot;car&quot; # &quot;car&quot; is stored in a variable item class(item) ## [1] &quot;character&quot; Character data types can have empty spaces in between, for instance; fullname = &quot;Salman Khan&quot; class(fullname) ## [1] &quot;character&quot; Logical They represent boolean values which has only distinct value; TRUE or FALSE. a=TRUE #logical data types is either TRUE or FALSE only class(a) ## [1] &quot;logical&quot; changing it to FALSE b = FALSE class(b) ## [1] &quot;logical&quot; Complex They represent complex numbers with real and imaginary parts a=2+3i # Complex data types have &#39;i&#39; at the end of each number class(a) ## [1] &quot;complex&quot; 2 is the real part while 3i is the imaginary part. Also, complex numbers can be created by complex() function with real and imaginary as the arguments. z = complex(real = 3, imaginary = 7) print(z) #show the comlex value ## [1] 3+7i class(z) #confirm that it is a complex number ## [1] &quot;complex&quot; Lets try another values to fit to the complex data type 2+5i z = complex(real=2, imaginary = 5) print(z) ## [1] 2+5i class(z) ## [1] &quot;complex&quot; 7 + 6i m=complex(real=7, imaginary = 6) print(m) ## [1] 7+6i class(m) ## [1] &quot;complex&quot; 4i - 1 b = 4i-1 print(b) ## [1] -1+4i class(b) ## [1] &quot;complex&quot; Complex data types can include the imaginary part only without real number, R will assume the real part to be 0(zero). For instance; h = 3i print(h) ## [1] 0+3i class(h) ## [1] &quot;complex&quot; Raw They represent a vector of bytes in their natural form. They are used in storing binary data. Example; a=charToRaw(&quot;DNA&quot;) print(a) ## [1] 44 4e 41 class(a) ## [1] &quot;raw&quot; # convert back to character b=rawToChar(a) class(b) ## [1] &quot;character&quot; “Hello world” can be represented as binary_data = charToRaw(&quot;Hello World&quot;) print(binary_data) ## [1] 48 65 6c 6c 6f 20 57 6f 72 6c 64 class(binary_data) ## [1] &quot;raw&quot; Numeric can also be represented as raw vectors; age=as.raw(27) print(age) ## [1] 1b class(age) ## [1] &quot;raw&quot; 3.2 Data Structures This is the organization of data into one or multiple data values in specific structures. Different types of data structures in R include; - Vector - Matrix - Data frame 3.2.1 Vector A vector is a single entity consisting of a collection of things. They are versatile providing a basis of many operations in statistics and data manipulation hence it is important to have knowledge of vectors for effective programming in R. Vectors are created using a c() function, here is an example of a vector. marks = c(23, 67, 98, 34, 98, 21) print(marks) ## [1] 23 67 98 34 98 21 The class function is utilized to determine the data types present within vector data values. class(marks) ## [1] &quot;numeric&quot; The vector “marks” consist of only numeric values is.vector function is used to check if the variable is a vector is.vector(marks) ## [1] TRUE unlike matrix and data frame, vector has no dimension dim(marks) ## NULL length() function is used to count number of elements in vectors length(marks) ## [1] 6 Index is the position of an element in a vector, in R it starts at index 1 - lets say we find the third element by index 3 marks[3] ## [1] 98 value “98” is at index 3, or the third in the vector. Vectors can be sliced to obtain values over a range of indices. For instance the code below shows how to retrieve the from the second to the fourth values as a vector print(marks[2:4]) ## [1] 67 98 34 is.vector(marks[2:4]) # confirm if the retrieved values are in a vector ## [1] TRUE An element at a specific index in a vector can be excluded by adding a - sign before the index value. marks[-2] #exclude the element at index 2 ## [1] 23 98 34 98 21 rev() command is used to reverse the order of elements in a vector rev(marks) ## [1] 21 98 34 98 67 23 3.2.1.1 Mathematical Operations in a vector The summary/descriptive statistics are calculated by summary() command. summary(marks) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 21.00 25.75 50.50 56.83 90.25 98.00 sum(), median(), and mean() are used to calculate the total, median, average and the standard deviation of the values in a vector print(&quot;MARKS&quot;) ## [1] &quot;MARKS&quot; print(paste(&quot;TOTAL: &quot;, sum(marks))) ## [1] &quot;TOTAL: 341&quot; print(paste(&quot;MEDIAN: &quot;, median(marks))) ## [1] &quot;MEDIAN: 50.5&quot; print(paste(&quot;AVERAGE: &quot;, mean(marks))) ## [1] &quot;AVERAGE: 56.8333333333333&quot; vector multiplication double_marks =2 * marks marks ## [1] 23 67 98 34 98 21 double_marks ## [1] 46 134 196 68 196 42 Vector division - divide the marks by 2 half_marks = marks/2 half_marks ## [1] 11.5 33.5 49.0 17.0 49.0 10.5 Multiply 2 vectors of equal length a = c(3, 5, 1) b = c(7, 3, 9) ab = a*b ab ## [1] 21 15 9 ba = b*a # is the same as ab ba ## [1] 21 15 9 Divide 2 vectors of equal length # Divide vector a by b abdiv=a/b abdiv ## [1] 0.4285714 1.6666667 0.1111111 # Divide vector b by a badiv=b/a badiv ## [1] 2.333333 0.600000 9.000000 However, when multiplying vectors of unequal length the shorter one is replicated to match the longer vector. It will then return a warning e=c(1,2,3,4,5) f=c(1,2) ef = e*f #it shows an error ## Warning in e * f: longer object length is not a multiple of shorter object ## length ef #shows results since f is replicated to match e as f=c(1,2,1,2,1) ## [1] 1 4 3 8 5 Multiple vectors can be concatenated/combined to come up with one giant vector a ## [1] 3 5 1 b ## [1] 7 3 9 z=c(a,b,a) #concatenates the vectors z ## [1] 3 5 1 7 3 9 3 5 1 3.2.1.2 Character Vectors Vectors can also contain character data types for instance my_name = c(&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;Vipin&quot;) my_name[5] = &quot;Singh&quot; #insert at the end my_name ## [1] &quot;My&quot; &quot;name&quot; &quot;is&quot; &quot;Vipin&quot; &quot;Singh&quot; Combining the vectors to a single string print(paste(my_name, collapse=&quot; &quot;)) ## [1] &quot;My name is Vipin Singh&quot; Calculate the summary/descriptive statistics of the vector by function summary(). It finds; - Count/length - Class (data type) - Mode summary(my_name) ## Length Class Mode ## 5 character character 3.2.1.3 Vectors with mixed data types A vector can also consist of characters values and numeric values for instance numbers=c(1,&quot;two&quot;, 3, &quot;three&quot;) numbers ## [1] &quot;1&quot; &quot;two&quot; &quot;3&quot; &quot;three&quot; however the numeric elements in the vector are recognized by R as character data type. They can be converted to numeric by; as.numeric(numbers[1]) + 2 ## [1] 3 the integers can be converted by; as.integer(numbers[1]) ## [1] 1 3.2.1.4 Named Vectors Variable names can be assigned to vectors like; named_vector=c(EcoR1=&quot;GAATTC&quot;, HindIII=&quot;AAGCTT&quot;, Pst1=&quot;CTGCAG&quot;) named_vector ## EcoR1 HindIII Pst1 ## &quot;GAATTC&quot; &quot;AAGCTT&quot; &quot;CTGCAG&quot; to access the names of the values is; names(named_vector) ## [1] &quot;EcoR1&quot; &quot;HindIII&quot; &quot;Pst1&quot; A vector element can be accessed using its name named_vector[&quot;EcoR1&quot;] # find the value of a vector by its name ## EcoR1 ## &quot;GAATTC&quot; 3.2.1.5 Generating number series as vectors The seq function in R is used to generate sequences of numbers. It takes several arguments, including from, to, by, and length.out, among others, to specify the range and increment of the sequence. Here’s a brief overview of its usage: from: The starting value of the sequence. to: The end value of the sequence. # Generate a sequence from 1 to 10 series = seq(from=1, to=20) series ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # It can also be written as series = seq(1,20) series ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class(series) ## [1] &quot;integer&quot; by: The increment between consecutive values in the sequence. # generate numbers 0 to 10 incremented by 0.5 series3=seq(0, 10, by=0.5) series3 ## [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 ## [16] 7.5 8.0 8.5 9.0 9.5 10.0 length: The desired length of the sequence. # generate 10 numbers from 0 to 6 series4=seq(0, 6, length=10) series4 ## [1] 0.0000000 0.6666667 1.3333333 2.0000000 2.6666667 3.3333333 4.0000000 ## [8] 4.6666667 5.3333333 6.0000000 seq(0, 6) ## [1] 0 1 2 3 4 5 6 along.with: An optional vector argument specifying the length and names of the output sequence. # Generate a sequence along with a vector seq(along.with = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] 1 2 3 3.2.1.6 Null data points in vectors NA data (Not available or blank) for instance marks=c(78,65, 98, 87, 89, NA) sum(is.na(marks)) #Count the null values in a vector ## [1] 1 Other inbuilt functions for mathematical operations cannot be done if Null values exists in a vector unless they are removed/ignored #sum(marks) #returns an error sum(marks, na.rm = TRUE) #remove null values before calculating the sum ## [1] 417 median(marks, na.rm = TRUE) ## [1] 87 summary(marks, na.rm = TRUE) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 65.0 78.0 87.0 83.4 89.0 98.0 1 3.2.2 Matrix A matrix is a two dimensional data type that contain a single class of data. The code below shows one can produce a matrix from a vector vector1 = seq(1, 9) # Convert to matrix ## create by column data1=matrix(vector1, ncol=3) data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 A vector of values 1 to 9 is being converted to a matrix where the values are being arranged column wise by default. A matrix has a multiple dimensions, the most common type of matrix is two dimesnional. dim(data1) ## [1] 3 3 is.matrix() function is used to confirm if a given variable is a matrix and it return a boolean value. is.matrix(data1) ## [1] TRUE A matrix can also be created row-wise from a vector. ## create by row data2=matrix(vector1, ncol=3, byrow=TRUE) data2 # is a transpose of data1 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Matrix is recognized either as a matrix or array by R class(data1) ## [1] &quot;matrix&quot; &quot;array&quot; To access a specific data point in a matrix, the matrix is indexed by row then column for instance matrix_data[row_index, column_index] data1[3, 2] ## [1] 6 To access a single row, in this case we find the second row which will be returned as a vector data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 row2 = data1[2,] # access row 2 is.vector(row2) #can be accessed by row 2 ## [1] TRUE To access a single column data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 col3=data1[,3] # access column 3 is.vector(col3) #can be accessed by column 3 ## [1] TRUE Count the number of rows in a matrix nrow(data1) ## [1] 3 data1 has 3 rows Count the number of columns in a matrix ncol(data1) ## [1] 3 3.2.2.1 Mathematical Operations in a matrix Matrix Addition data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 data2 = data1 + 3 data2 ## [,1] [,2] [,3] ## [1,] 4 7 10 ## [2,] 5 8 11 ## [3,] 6 9 12 Adding value 3 to a matrix adds each value in the matrix by 3 Matrix Subtraction data3 = data1-1 #reduce each value by 1 data3 ## [,1] [,2] [,3] ## [1,] 0 3 6 ## [2,] 1 4 7 ## [3,] 2 5 8 Subtracting 1 to data1 subtract each value in the matrix by 1 Matrix Multiplication(scalar) data4 = data1*5 data4 ## [,1] [,2] [,3] ## [1,] 5 20 35 ## [2,] 10 25 40 ## [3,] 15 30 45 Matrix division data5 = data1/2 data5 ## [,1] [,2] [,3] ## [1,] 0.5 2.0 3.5 ## [2,] 1.0 2.5 4.0 ## [3,] 1.5 3.0 4.5 3.2.3 Data frame is a two dimensional data structure, like a 2d array/matrix with rows and columns. Lets convert a matrix into a dataframe vector1 = c(1:12) matrix1 = matrix(vector1, ncol=4) #create a matrix from the vector # Adding a column student Students=c(&quot;Pragya&quot;, &quot;Deepika&quot;, &quot;Chandran&quot;) data = data.frame(Students, matrix1) data ## Students X1 X2 X3 X4 ## 1 Pragya 1 4 7 10 ## 2 Deepika 2 5 8 11 ## 3 Chandran 3 6 9 12 The above data shows scores of different students in different subjects. The column names are automatically generated by R, however, the column names can be added as below. headers=c(&quot;Students&quot;, &quot;Geonomics&quot;, &quot;Proteomics&quot;, &quot;Microbiology&quot;, &quot;Biostatistics&quot;) colnames(data)=headers #add column names data ## Students Geonomics Proteomics Microbiology Biostatistics ## 1 Pragya 1 4 7 10 ## 2 Deepika 2 5 8 11 ## 3 Chandran 3 6 9 12 A rowwise addition can be performed on a data frame to find the total scores for each student in the four units ## Add a new column with total marks obtained data$total_marks=rowSums(data[, c(2, 3, 4, 5)]) #add from second to fifth column data ## Students Geonomics Proteomics Microbiology Biostatistics total_marks ## 1 Pragya 1 4 7 10 22 ## 2 Deepika 2 5 8 11 26 ## 3 Chandran 3 6 9 12 30 Find the average score for each student. data$average_marks=rowMeans(data[, c(2, 3, 4, 5)]) data ## Students Geonomics Proteomics Microbiology Biostatistics total_marks ## 1 Pragya 1 4 7 10 22 ## 2 Deepika 2 5 8 11 26 ## 3 Chandran 3 6 9 12 30 ## average_marks ## 1 5.5 ## 2 6.5 ## 3 7.5 "],["loops.html", "Chapter 4 Loops 4.1 For loops 4.2 While loop", " Chapter 4 Loops A loop is a sequence of instructions that are executed iterative until a condition is met. They are two types of loops in R, they are; - for loops - while loops 4.1 For loops This is a type of a loop that iterate over a sequence of elements, such as a vector, list, or sequence of numbers, executing a block of code for each element in the sequence. The loop iterates over each element of the sequence, one at a time, and executes the specified code block for each iteration. Here is the syntax of a for loop for (variable in sequence) { # Code block to be executed for each iteration } When a condition is met the execution/iteration stops Below is an example of R loop over a range of numbers 1 to 10 for (n in 1:10) { print(n*5) } ## [1] 5 ## [1] 10 ## [1] 15 ## [1] 20 ## [1] 25 ## [1] 30 ## [1] 35 ## [1] 40 ## [1] 45 ## [1] 50 The loop can also iterate over a vector and perform the preset condition. For instance in the code below, the loops through a vector and prints a square of each element in the vector. num=c(1,2,3,8,10) for (n in 1:length(num)) { print(num[n]^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 64 ## [1] 100 Breaking of a loop - a program stops once something happens for instance the below loops executes by incrementing n and breaks when n is greater than 7 #Stop the loop if the n is greater than 7 for (n in num) { if (n &gt; 7){ break } print(n) } ## [1] 1 ## [1] 2 ## [1] 3 4.2 While loop A while loop is a control flow statement in programming that repeatedly executes a block of code as long as a specified condition is true. The loop continues to execute until the condition becomes false. The below program executes as long as n is less than or equal to m. m=4 n=-9 while(n&lt;=m) { print(n) n=n+1 } ## [1] -9 ## [1] -8 ## [1] -7 ## [1] -6 ## [1] -5 ## [1] -4 ## [1] -3 ## [1] -2 ## [1] -1 ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 "],["working-with-files.html", "Chapter 5 Working with files 5.1 Reading a file from a dataframe 5.2 Write a new table to a file locally", " Chapter 5 Working with files 5.1 Reading a file from a dataframe This chapter explains how to read a file to a data frame using the readxl library. The readxl package can be installed from the console by install.packages(\"readxl\") command. Lets begin by importing the library # Import the library library(readxl) The readxl library can read .xlsx, xls files to a data frame. For this case, Human genome excel file is read. hg = read_excel(&quot;data/Human_genome.xlsx&quot;) View the data View(hg) In R, head() and tail() are functions used to view the first few rows or the last few rows of a data frame respectively. These functions are particularly useful for quickly inspecting the structure and content of a dataset. Here’s how you can use them for this case; head(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The head() function displays the first few rows of a data frame or a vector. By default, it shows the first 6 rows, but you can specify the number of rows to display using the n argument. head(hg, n=10) ## # A tibble: 10 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The tail argument can be used as; tail(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; to show the last 6 records while specifying n value will show the specified number of rows. R identifies this type of data as table or data frame. class(hg) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str() is used to find the nature of data such as column data types, number of rows and columns, column names , and first records in the dataframe str(hg) ## tibble [25 × 8] (S3: tbl_df/tbl/data.frame) ## $ Chromosome : chr [1:25] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Base_Pairs : num [1:25] 2.49e+08 2.42e+08 1.98e+08 1.90e+08 1.82e+08 ... ## $ Protein_Coding_genes : num [1:25] 2058 1309 1078 752 876 ... ## $ Pseudogenes : num [1:25] 1220 1023 763 727 721 ... ## $ Total_long_non_coding_RNA: num [1:25] 1200 1037 711 657 844 ... ## $ Total_small_nc_RA : num [1:25] 496 375 298 228 235 234 208 214 190 204 ... ## $ miRNA : num [1:25] 134 115 99 92 83 81 90 80 69 64 ... ## $ rRNA : num [1:25] 66 40 29 24 25 26 24 28 19 32 ... is.na() is used to check if there is null/blank values in the dataset. If there is it returns TRUE in place of the null point while it return FALSE in place of the value. sum(is.na(hg)) ## [1] 0 The “hg” data frame has no null values. Lets dive into biology to solve some of the questions about genetics Q1. Calculate the gene densityfor each chromosome The gene density is calculated in terms of genes per megabase base_Mb = hg$Base_Pairs/1000000 base_Mb ## [1] 248.956422 242.193529 198.295559 190.214555 181.538259 170.805979 ## [7] 159.345973 145.138636 138.394717 133.797422 135.086622 133.275309 ## [13] 114.364328 107.043718 101.991189 90.338345 83.257441 80.373285 ## [19] 58.617616 64.444167 46.709983 50.818468 156.040895 57.227415 ## [25] 0.016569 To make the values more clear, the results can be rounded off to two decimal place. rbase_Mb=round(base_Mb, digits = 2) rbase_Mb ## [1] 248.96 242.19 198.30 190.21 181.54 170.81 159.35 145.14 138.39 133.80 ## [11] 135.09 133.28 114.36 107.04 101.99 90.34 83.26 80.37 58.62 64.44 ## [21] 46.71 50.82 156.04 57.23 0.02 Q2. Calculate number of genes per megabase per chromosomes The protein coding genes are divided to the gene density. genes_per_megabase = round(hg$Protein_Coding_genes/base_Mb, digits = 2) genes_per_megabase ## [1] 8.27 5.40 5.44 3.95 4.83 6.14 6.21 4.66 5.68 5.48 ## [11] 9.61 7.76 2.86 7.75 6.01 9.66 14.38 3.36 25.11 8.44 ## [21] 5.01 9.60 5.40 1.24 784.60 Lets create a new column to the dataframe to the dataset hg[&quot;genes_per_Mb&quot;]=genes_per_megabase str(hg) ## tibble [25 × 9] (S3: tbl_df/tbl/data.frame) ## $ Chromosome : chr [1:25] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Base_Pairs : num [1:25] 2.49e+08 2.42e+08 1.98e+08 1.90e+08 1.82e+08 ... ## $ Protein_Coding_genes : num [1:25] 2058 1309 1078 752 876 ... ## $ Pseudogenes : num [1:25] 1220 1023 763 727 721 ... ## $ Total_long_non_coding_RNA: num [1:25] 1200 1037 711 657 844 ... ## $ Total_small_nc_RA : num [1:25] 496 375 298 228 235 234 208 214 190 204 ... ## $ miRNA : num [1:25] 134 115 99 92 83 81 90 80 69 64 ... ## $ rRNA : num [1:25] 66 40 29 24 25 26 24 28 19 32 ... ## $ genes_per_Mb : num [1:25] 8.27 5.4 5.44 3.95 4.83 6.14 6.21 4.66 5.68 5.48 ... 5.2 Write a new table to a file locally The write.table() function is used to write table to file on a local machine. The file is saved by deault to the working directory unless the path is specified. write.table(hg, file=&quot;data/hg_modified&quot;, quote=FALSE, sep=&#39;\\t&#39;, row.names=FALSE, col.names=TRUE) This file will be saved by default on the working directory unless the file path is changed. Checking if the new file is saved. file.show(&quot;data/hg_modified&quot;) "],["dpyr-library.html", "Chapter 6 Dpyr library 6.1 Application of Dplyr on Microbiology", " Chapter 6 Dpyr library readxl library has been used to read excel table into R and manipulate the data using R basic functions, now dplyr library will be used. This, dplyr library is an advanced package that has functions used to manipulate data. The functions are referred to as dplyr verbs. This are some opf the examples of dplyr verbs; - select - filter - arrange - mutate - group by - summarise &lt;–EXPLAIN THE PROCESS OF dplyr INSTALLATION USING RSTUDIO –&gt; #uncomment the below line to install dplyr #install.packages(&quot;dplyr&quot;) Load the required libraries library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(readxl) Before working on the data, the readxl package will be used to read the excel table. Then manipulate the data withndplyr. hg = read_excel(&quot;data/Human_genome.xlsx&quot;) tail(hg) #display the last 6 records of the data ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Apart from data retrieved from excel tables, there are some inbuilt freeely available datasets in R that a student can use for practice. data() function can be used to view some of the freely available datasets in R. data() or ls(&quot;package:datasets&quot;) ## [1] &quot;ability.cov&quot; &quot;airmiles&quot; &quot;AirPassengers&quot; ## [4] &quot;airquality&quot; &quot;anscombe&quot; &quot;attenu&quot; ## [7] &quot;attitude&quot; &quot;austres&quot; &quot;beaver1&quot; ## [10] &quot;beaver2&quot; &quot;BJsales&quot; &quot;BJsales.lead&quot; ## [13] &quot;BOD&quot; &quot;cars&quot; &quot;ChickWeight&quot; ## [16] &quot;chickwts&quot; &quot;co2&quot; &quot;CO2&quot; ## [19] &quot;crimtab&quot; &quot;discoveries&quot; &quot;DNase&quot; ## [22] &quot;esoph&quot; &quot;euro&quot; &quot;euro.cross&quot; ## [25] &quot;eurodist&quot; &quot;EuStockMarkets&quot; &quot;faithful&quot; ## [28] &quot;fdeaths&quot; &quot;Formaldehyde&quot; &quot;freeny&quot; ## [31] &quot;freeny.x&quot; &quot;freeny.y&quot; &quot;HairEyeColor&quot; ## [34] &quot;Harman23.cor&quot; &quot;Harman74.cor&quot; &quot;Indometh&quot; ## [37] &quot;infert&quot; &quot;InsectSprays&quot; &quot;iris&quot; ## [40] &quot;iris3&quot; &quot;islands&quot; &quot;JohnsonJohnson&quot; ## [43] &quot;LakeHuron&quot; &quot;ldeaths&quot; &quot;lh&quot; ## [46] &quot;LifeCycleSavings&quot; &quot;Loblolly&quot; &quot;longley&quot; ## [49] &quot;lynx&quot; &quot;mdeaths&quot; &quot;morley&quot; ## [52] &quot;mtcars&quot; &quot;nhtemp&quot; &quot;Nile&quot; ## [55] &quot;nottem&quot; &quot;npk&quot; &quot;occupationalStatus&quot; ## [58] &quot;Orange&quot; &quot;OrchardSprays&quot; &quot;PlantGrowth&quot; ## [61] &quot;precip&quot; &quot;presidents&quot; &quot;pressure&quot; ## [64] &quot;Puromycin&quot; &quot;quakes&quot; &quot;randu&quot; ## [67] &quot;rivers&quot; &quot;rock&quot; &quot;Seatbelts&quot; ## [70] &quot;sleep&quot; &quot;stack.loss&quot; &quot;stack.x&quot; ## [73] &quot;stackloss&quot; &quot;state.abb&quot; &quot;state.area&quot; ## [76] &quot;state.center&quot; &quot;state.division&quot; &quot;state.name&quot; ## [79] &quot;state.region&quot; &quot;state.x77&quot; &quot;sunspot.month&quot; ## [82] &quot;sunspot.year&quot; &quot;sunspots&quot; &quot;swiss&quot; ## [85] &quot;Theoph&quot; &quot;Titanic&quot; &quot;ToothGrowth&quot; ## [88] &quot;treering&quot; &quot;trees&quot; &quot;UCBAdmissions&quot; ## [91] &quot;UKDriverDeaths&quot; &quot;UKgas&quot; &quot;USAccDeaths&quot; ## [94] &quot;USArrests&quot; &quot;UScitiesD&quot; &quot;USJudgeRatings&quot; ## [97] &quot;USPersonalExpenditure&quot; &quot;uspop&quot; &quot;VADeaths&quot; ## [100] &quot;volcano&quot; &quot;warpbreaks&quot; &quot;women&quot; ## [103] &quot;WorldPhones&quot; &quot;WWWusage&quot; The above datasets are available in base R however some of the packages come with the newly installed packages. The data from all the packages can be viewd by data(package=.packages(all.available = TRUE)) A good example is the famous iris dataset that will be used in this course. The data will be invoked to R before assessment and wrangling. data(&quot;iris&quot;) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Calculating the summary statistics summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Lets write this dataset locally to a file. write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) or to remove quotes next to values write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE, quote = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) or to remove quotes and row names &lt;– remember to add screenshots–&gt; write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE, quote=FALSE, row.names = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) Chaining Chaining is the process of combining several operations together using the %&gt;% or forward pipe operator. The chained workflow succeeds each other until the whole process is done. 6.1 Application of Dplyr on Microbiology Genetics composition of an organism can be analyzed using dplyr, in this course unit it will be used to analyze the human genetics data. Read the dataset from a file into a dataframe hg = read_excel(&quot;data/Human_genome.xlsx&quot;) class(hg) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; review the first six records of the dataset head(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; the last six records of the dataset tail(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; sample_n() command is used to randomly sample fixed number of rows from the data frame. Lets sample five rows randomly hg %&gt;% sample_n(5) ## # A tibble: 5 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 13 114364328 327 372 397 ## 2 16 90338345 873 465 799 ## 3 Y 57227415 71 388 71 ## 4 6 170805979 1048 801 639 ## 5 1 248956422 2058 1220 1200 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; sample_fra() command can also be used to extract a percent of rows randomly. Lets samople 25% of the rows hg %&gt;% sample_frac(0.25, replace = FALSE) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 22 50818468 488 324 357 ## 2 16 90338345 873 465 799 ## 3 14 107043718 830 523 533 ## 4 9 138394717 786 661 491 ## 5 2 242193529 1309 1023 1037 ## 6 15 101991189 613 510 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The replace argument allows repetition of rows when sampling when set TRUE and vice versa. The essence of dplyr in microbiology data can be explained better by questions. Q1. Which chromosomes has maximum size The functions used here are; select, arrange, slice The required columns will be selected i.e Chromosomes and Base_Pairs(size) The data will ordered according to Base_Pairs in descending order by the arrange command. the data will be “sliced” to select the first row All these processes will be chained to run progressively from process 1 to 3. All the above steps should be piped hg1 = hg %&gt;% #transfer the data to a new variable select(Chromosome, Base_Pairs) %&gt;% # select the required columns arrange(desc(Base_Pairs)) %&gt;% #order in descending order slice(1) hg1 ## # A tibble: 1 × 2 ## Chromosome Base_Pairs ## &lt;chr&gt; &lt;dbl&gt; ## 1 1 248956422 Q2. List of Chromosomes with more than 500 pseudogenes and more than 1000 protein coding genes The human genome data frame will be filtered to find the Chromosomes with more than 500 pseudogenes and more than 1000 protein coding genes. &amp; condition is used in the filter hg2=hg%&gt;% filter(Pseudogenes&gt;500 &amp; Protein_Coding_genes&gt;1000) hg2 ## # A tibble: 8 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 6 170805979 1048 801 639 ## 5 11 135086622 1298 821 710 ## 6 12 133275309 1034 617 848 ## 7 17 83257441 1197 531 834 ## 8 19 58617616 1472 512 628 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Q3. List of Chromosomes with more tha 500 pseudogenes or more than 1000 protein coding genes and miRNA more than 100 a frame will be filtered to find the Chromosomes with more than 500 pseudogenes The human genome dator more than 1000 protein coding genes and mtRNA more than 100. The &amp; and | conditions will be used in place of “and” and “or” respectively. hg2=hg %&gt;% filter((Pseudogenes&gt;500|Protein_Coding_genes&gt;1000) &amp; miRNA&gt;100) hg2 ## # A tibble: 4 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 19 58617616 1472 512 628 ## 4 X 156040895 842 874 271 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Q4. Which 10 Chromosomes have the highest protein gene density (Genes per megabase) Mutate -&gt; is a command to create a new column Lets create a column of genes per megabase where a megabase is 1000000 base pairs hg3=hg %&gt;% mutate(Genes_per_Mb=round((Protein_Coding_genes/(Base_Pairs/100000)), digit=2)) hg3 ## # A tibble: 25 × 9 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ 15 more rows ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 4 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt;, ## # Genes_per_Mb &lt;dbl&gt; then order the data according to genes per megabse column (Genes_per_mb) in descending order and select the first 10 rows using arrange and select commands. hg4=hg3 %&gt;% arrange(desc(Genes_per_Mb)) %&gt;% # order in descending order select(Chromosome, Genes_per_Mb) %&gt;% # select the required columns slice(1:10) # select the top 10 hg4 ## # A tibble: 10 × 2 ## Chromosome Genes_per_Mb ## &lt;chr&gt; &lt;dbl&gt; ## 1 mtDNA 78.5 ## 2 19 2.51 ## 3 17 1.44 ## 4 16 0.97 ## 5 11 0.96 ## 6 22 0.96 ## 7 20 0.84 ## 8 1 0.83 ## 9 12 0.78 ## 10 14 0.78 Q5. Calculate the mean of gene density for autosomes, sex chromosomes and mitochondrial genes autosomes=rep(&quot;A&quot;, 22) #create a vector with 22 As print(autosomes) ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [20] &quot;A&quot; &quot;A&quot; &quot;A&quot; chr_class=c(autosomes, &quot;S&quot;, &quot;S&quot;, &quot;M&quot;) chr_class ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [20] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;S&quot; &quot;S&quot; &quot;M&quot; hg5= hg3 %&gt;% mutate(Type=chr_class) hg5 # confirm the new column &quot;Type&quot; is added ## # A tibble: 25 × 10 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ 15 more rows ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 5 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt;, ## # Genes_per_Mb &lt;dbl&gt;, Type &lt;chr&gt; Group by chromosomes and calculate the mean density hg6=hg5 %&gt;% group_by(Type) %&gt;% summarise(gene_density=mean(Genes_per_Mb)) hg6 ## # A tibble: 3 × 2 ## Type gene_density ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 0.754 ## 2 M 78.5 ## 3 S 0.33 "],["ggplot.html", "Chapter 7 GGPLOT 7.1 Five key steps to ggplot 7.2 Biology behind the data we are using 7.3 Prepare the data for plotting - Data Assessment 7.4 Plotting 7.5 Working with inbuilt iris data", " Chapter 7 GGPLOT ggplot2 is a powerful data visualization package in R that allows you to create a wide variety of graphs and plots. It is based on the grammar of graphics, a structured approach to constructing plots that emphasizes the mapping of data to visual attributes. 7.1 Five key steps to ggplot There are 5 key steps in plotting in ggplot 1.The Setup - Read the dataset, define x and y axis The Labels - Title, X and Y axis labels The Theme - Default, Black and White, coloured etc. The Facets - Individual Graphs for each group in data with exactly same range The Layers or geoms - The actual plot type - e.g Bar plot, Box plot, Violin plot etc. 7.2 Biology behind the data we are using &lt;–Review the slide on minute 3 video 7–&gt; GGplot installation #uncomment the below line to install ggplot package #install.packages(&quot;ggplot2&quot;) 7.3 Prepare the data for plotting - Data Assessment Invoke the libraries library(ggplot2) library(data.table) ## ## Attaching package: &#39;data.table&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last Read the data using the fread function methylated_c = fread(&quot;data/R_WORKSHOP.csv&quot;, header=T, sep=&quot;,&quot;) View the first ficve records of the data head(methylated_c) ## Chromosome Context Count Count_in_millions ## &lt;char&gt; &lt;char&gt; &lt;int&gt; &lt;num&gt; ## 1: Chr1 CG 1394740 1.394740 ## 2: Chr2 CG 915144 0.915144 ## 3: Chr3 CG 1118062 1.118062 ## 4: Chr4 CG 879170 0.879170 ## 5: Chr5 CG 1260598 1.260598 ## 6: Chr1 CHG 1543980 1.543980 Look at the nature of the data str(methylated_c) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 15 obs. of 4 variables: ## $ Chromosome : chr &quot;Chr1&quot; &quot;Chr2&quot; &quot;Chr3&quot; &quot;Chr4&quot; ... ## $ Context : chr &quot;CG&quot; &quot;CG&quot; &quot;CG&quot; &quot;CG&quot; ... ## $ Count : int 1394740 915144 1118062 879170 1260598 1543980 988829 1225767 957674 1377407 ... ## $ Count_in_millions: num 1.395 0.915 1.118 0.879 1.261 ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; In the dataset, there are numeric variables a well as character columns. There are 15 records in the dataset Calculate the summary statistics summary(methylated_c) ## Chromosome Context Count Count_in_millions ## Length:15 Length:15 Min. : 879170 Min. :0.8792 ## Class :character Class :character 1st Qu.:1053446 1st Qu.:1.0534 ## Mode :character Mode :character Median :1377407 Median :1.3774 ## Mean :2857317 Mean :2.8573 ## 3rd Qu.:5025181 3rd Qu.:5.0252 ## Max. :7917805 Max. :7.9178 Do the data have null values? sum(is.na(methylated_c)) ## [1] 0 This data does not have any null values. class(methylated_c) ## [1] &quot;data.table&quot; &quot;data.frame&quot; 7.4 Plotting 7.4.1 Base set up Before plotting the data, you need to: - Define the graph skeleton - Define the aesthetics - Define the labels graph=ggplot(methylated_c, aes(x=Chromosome, y=Count_in_millions))+ #graph aesthetics labs(x=&quot;Chromosomes&quot;, y=&quot;Cytosine count in millions&quot;, title=&quot;C distribution in A thaliana&quot;) #graph labels print(graph) Define the type of graph - geoms. For this case, the graph is a bar graph graph1 = graph + geom_col() #plot a bar chart print(graph1) Add some depth to the chart - introduce the third variable “Context” Make it a stacked bar chart graph2=graph1+aes(fill=Context) print(graph2) The graphs can also be a grouped bar chart when the position is defined as “dodge” upon further modifications graph3=graph+geom_col(position=&quot;dodge&quot;)+aes(fill=Context) print(graph3) Faceting - Group the charts by context Faceted graphs - these are related data plotted separately on the same image/diagram. graph4=graph3+facet_grid(~Context) print(graph4) GGPlot randomly select colours to paint the graph but the biologist/statistician can use predefined colours as below. graph5=graph4+scale_fill_manual(values=c(&quot;brown&quot;, &quot;blue&quot;, &quot;red&quot;)) print(graph5) Modifying the background colour graph5+theme_bw(base_size=9)+theme(panel.background = element_rect(fill=&quot;lightblue&quot;)) All of the above steps can be combined to come up with a decent graph from ggplot library. my_title = expression(paste(&quot;Cystosine distribution in &quot;, italic(&quot;Arabidopis thaliana&quot;)))#Define the title graph_final = ggplot(methylated_c, aes(x=Chromosome, y=Count_in_millions))+ labs(x=&quot;Chromosomes&quot;, title = my_title) + facet_grid(~Context) + geom_col(position=&quot;dodge&quot;)+ aes(fill=Context)+scale_fill_manual(values = c(&quot;brown&quot;, &quot;blue&quot;, &quot;red&quot;))+ theme_bw(base_size = 9)+theme(panel.background = element_rect(fill=&quot;lightblue&quot;)) print(graph_final) The expression is used to combine name italics and normal fonts - this helps biologists include botanical names in charts The graphs can be exported as images or pdf. This can be done in RStudio &lt;–Show screenshots if possible–&gt; 7.5 Working with inbuilt iris data plot a box plot to compare the sepal length in diferent iris species graph = ggplot(iris, aes(x=Species, y=Sepal.Length))+ geom_boxplot()+aes(fill=Species) print(graph) Virginica have higher sepal length however some virginica have less sepal length than versicolor Violin plot will show a better distribution than boxplot graph = ggplot(iris, aes(x=Species, y=Sepal.Length))+ geom_violin()+aes(fill=Species) print(graph) tidyr this package is used to reshape data especially from a long format to a short format. # uncomment the below line to install the library #install.packages(&quot;tidyr&quot;) Invoke the library library(tidyr) # can be used to convert from short format to long format Convert to a long format gather command is used to convert data into fewer columns. The columns from sepal length to petal width are to be merged to a single column called messearements #Gather from sepal length to petal width column into type and measurement column iris_long = gather(iris, type, measurement, Sepal.Length:Petal.Width, factor_key = TRUE) tail(iris_long) ## Species type measurement ## 595 virginica Petal.Width 2.5 ## 596 virginica Petal.Width 2.3 ## 597 virginica Petal.Width 1.9 ## 598 virginica Petal.Width 2.0 ## 599 virginica Petal.Width 2.3 ## 600 virginica Petal.Width 1.8 Lets plot the data to a boxplot graph=ggplot(iris_long, aes(x=Species,y=measurement))+ labs(x=&quot;Species&quot;, y=&quot;Length in cm&quot;, title = &quot;variation in Petals and Sepals of Iris Species&quot;)+ theme(axis.text = element_text(angle=90))+ facet_grid(~type)+ aes(fill=Species)+ geom_boxplot() print(graph) the same can also be plotted to a violin plot graph=ggplot(iris_long, aes(x=Species,y=measurement))+ labs(x=&quot;Species&quot;, y=&quot;Length in cm&quot;, title = &quot;variation in Petals and Sepals of Iris Species&quot;)+ theme(axis.text = element_text(angle=90))+ facet_grid(~type)+ aes(fill=Species)+ geom_violin() print(graph) "],["bioconductor.html", "Chapter 8 Bioconductor 8.1 Installing BiocManager Package 8.2 Searching and Analyzing the strings 8.3 Using seqinr 8.4 Using Short Read", " Chapter 8 Bioconductor Bioconductor is a repository for high-quality, peer-reviewed software packages for the analysis and comprehension of high-throughput genomic data. Here’s a guide on how to utilize some of its functionalities: 8.1 Installing BiocManager Package To get started with Bioconductor, you need to install the BiocManager package, which facilitates the installation and management of Bioconductor packages. You can find detailed installation instructions in the official documentation. Load the required libraries library(Biostrings) ## Loading required package: BiocGenerics ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## combine, intersect, setdiff, union ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, append, as.data.frame, basename, cbind, colnames, ## dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep, ## grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply, ## union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ## ## Attaching package: &#39;S4Vectors&#39; ## The following object is masked from &#39;package:tidyr&#39;: ## ## expand ## The following objects are masked from &#39;package:data.table&#39;: ## ## first, second ## The following objects are masked from &#39;package:dplyr&#39;: ## ## first, rename ## The following objects are masked from &#39;package:base&#39;: ## ## expand.grid, I, unname ## Loading required package: IRanges ## ## Attaching package: &#39;IRanges&#39; ## The following object is masked from &#39;package:data.table&#39;: ## ## shift ## The following objects are masked from &#39;package:dplyr&#39;: ## ## collapse, desc, slice ## Loading required package: XVector ## Loading required package: GenomeInfoDb ## ## Attaching package: &#39;Biostrings&#39; ## The following object is masked from &#39;package:base&#39;: ## ## strsplit After loading the necessary libraries, you can read sequence data into R. For instance, if you have sequence data stored in a multifasta file named multifasta_seq.txt, you can use the readDNAStringSet() function. seq = readDNAStringSet(&quot;data/multifasta_seq.txt&quot;) ## Warning in .Call2(&quot;fasta_index&quot;, filexp_list, nrec, skip, seek.first.rec, : ## reading FASTA file data/multifasta_seq.txt: ignored 2545 invalid one-letter ## sequence codes seq ## DNAStringSet object of length 6: ## width seq names ## [1] 844 MVVVSSCVNTTRTAYTNSTRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV2_2019 ## [2] 842 MTTSGSDDRCTTDDVANYTHTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV ## [3] 841 MVVVSSCVNTTRTAYTNSSTRGV...KGCCSCGSCCKDDDSVKGVKHYT Spike_Bat_coronav... ## [4] 834 MVVVSSCVNTTRTGGYTNSSTRG...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [5] 846 MHAVNSCVNTGRAASTNSSRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [6] 835 MKVVATVSSYTKCDDDRTANTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_WIV1_Bat_Co... Each genomic sequence can be viewed separately by indexing seq[[1]] #first genomic sequence ## 844-letter DNAString object ## seq: MVVVSSCVNTTRTAYTNSTRGVYYDKVRSSVHSTDS...MVTMCCMTSCCSCKGCCSCGSCCKDDDSVKGVKHYT seq[[2]] # second genomic sequence ## 842-letter DNAString object ## seq: MTTSGSDDRCTTDDVANYTHTSSMRGVYYDRSDTYT...VMVTCCMTSCCSCKGACSCGSCCKDDDSVKGVKHYT Convert to character to inspect its content. as.character(seq[[1]]) ## [1] &quot;MVVVSSCVNTTRTAYTNSTRGVYYDKVRSSVHSTDSNVTWHAHVSGTNGTKRDNVNDGVYASTKSNRGWGTTDSKTSVNNATNVVKVCCNDGVYYHKNNKSWMSRVYSSANNCTYVSMDGKGNKNRVKNDGYKYSKHTNVRDGSAVDGNTRTAHRSYTGDSSSGWTAGAAAYYVGYRTKYNNGTTDAVDCADSTKCTKSTVKGYTSNRVTSVRNTNCGVNATRASVYAWNRKRSNCVADYSVYNSASSTKCYGVSTKNDCTNVYADSVRGDVRAGTGKADYNYKDDTGCVAWNSNNDSKVGGNYNYYRRKSNKRDSTYAGSTCNGVGNCYSYGTNGVGYYRVVVSHAATVCGKKSTNVKNKCVNNNGTGTGVTSNKKGRDADTTDAVRDTDTCSGGVSVTGTNTSNVAVYDVNCTVVAHADTTWRVYSTGSNVTRAGCGAHVNNSYCDGAGCASYTTNSRRARSVASSAYTMSGANSVAYSNNSATNTSVTTVSMTKTSVDCTMYCGDSTCSNYGSCTNRATGAVDKNTVAVKYKTKDGGNSDSKSKRSDNKVTADAGKYGDCGDAARDCAKNGTVTDMAYTSAAGTTSGWTGAGAAAMMAYRNGGVTNVYNKANNSAGKDSSSTASAGKDVVNNAANTVKSSNGASSVNDSRDKVAVDRTGRSTYVTRAARASANAATKMSCVGSKRVDCGKGYHMSSAHGVVHVTYVAKNTTAACHDGKAHRGVVSNGTHWVTRNYTTDNTVSGNCDVVGVNNTVYDDSKDKYKNHTSDVDGDSGNASVVNKDRNVAKNNSDGKYYKWWYWGAGAVMVTMCCMTSCCSCKGCCSCGSCCKDDDSVKGVKHYT&quot; The length function from base R is used to count the number of genomic sequences. length(seq) ## [1] 6 Names of the sequences names(seq) ## [1] &quot;Spike_SARS_CoV2_2019&quot; &quot;Spike_SARS_CoV&quot; ## [3] &quot;Spike_Bat_coronavirus_RaTG13&quot; &quot;Spike_Pangolin_coronavirus_GX&quot; ## [5] &quot;Spike_Pangolin_coronavirus_GD&quot; &quot;Spike_WIV1_Bat_Coronovirus&quot; view the first 6 sequences head(seq) ## DNAStringSet object of length 6: ## width seq names ## [1] 844 MVVVSSCVNTTRTAYTNSTRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV2_2019 ## [2] 842 MTTSGSDDRCTTDDVANYTHTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV ## [3] 841 MVVVSSCVNTTRTAYTNSSTRGV...KGCCSCGSCCKDDDSVKGVKHYT Spike_Bat_coronav... ## [4] 834 MVVVSSCVNTTRTGGYTNSSTRG...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [5] 846 MHAVNSCVNTGRAASTNSSRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [6] 835 MKVVATVSSYTKCDDDRTANTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_WIV1_Bat_Co... Checking the reverse compliment of sequence seq_rc = reverseComplement(seq[[1]]) head(seq_rc) ## 6-letter DNAString object ## seq: ARDMBC tail(seq_rc) ## 6-letter DNAString object ## seq: SSBBBK as.character(seq_rc) ## [1] &quot;ARDMBCMBSHHHMGGSCGSGGCMGSGGSAKGGKABKBTCTCWRWWMRRMCHSNNMTBNYHMNBBSTNCSHCHBHSADNMRMHMSHHRBANNBCBBHGNCSBANHAARNYABWDACNSBBCYDTMCHDGTTAANMTBRABDBBCDTSSKDRCMCGHBYMSCBGSKMATTNTSTYTTYABRASYCAYHBTBMHYSHNBSSTCNSSMBANTTNNBBHMCTSTASSSHMCTSNNTMNRBNABCCNYRTKKTTTCTCAWCSAACTTSARTKHABACNMTGHYTTHCGHCRMCTHTABMNHSYMSMSHSNCCHMAMRMBTBANMHBTCATYNAGSCRNSGASHCGRKAGHBSAMAKSBAABSANATSNNSRTBSNTCSKARTSSTBSYTYYSNAARSTGCTCHGRSNNBDTCGCTYABNSCASRBYWAAHTDTBBAGNBHRBTBNSANACABSBCCSGAHAHYBTHAAHTHYCMMNSABCACACNNNBGMNMBNASMMCGBATTDSBBBYRRCBCNACRSRGNCBCNGASCTRASHYMNSMYYRRNRNCCBMSHNNSNWTBGCAHHMRNRHTMCACTYBHCYBSHTRBNAGHNMASBCRGMASSTSNRBSRHTBGNSYMYNWTRBSTYATNBCGNANYBSABYNSARCMBASMAGMASHTGHBTHAACNNRMAYRCBRRTTTCTAWCSSSHCARSYDTAYANCHBTSCHYBNADMSRMRCHNMBYNMNCMCHKSBRAGNNTSSRBYSKWSMNNMDRRBCHNGGBMBBNATNNBSAMSHAACWCYNSMASTRBCHNBNHYMACNACSBDTDWABNSHASDBSSYBMHRRBCYASNARTAYAANBGSSBBBK&quot; Sequence composition -default - calculate the DNA composition composition=alphabetFrequency(seq) print(composition) ## A C G T M R W S Y K V H D B N - + . ## [1,] 79 40 82 97 14 42 12 99 54 61 97 17 62 0 88 0 0 0 ## [2,] 84 39 78 100 20 39 11 96 54 60 91 15 74 0 81 0 0 0 ## [3,] 80 40 82 98 14 39 12 97 55 63 94 18 64 0 85 0 0 0 ## [4,] 76 40 85 98 15 41 12 94 55 61 97 17 61 0 82 0 0 0 ## [5,] 82 40 81 99 15 40 12 100 60 58 95 14 60 0 90 0 0 0 ## [6,] 82 39 77 93 17 42 11 98 50 60 93 15 72 0 86 0 0 0 Specific composition - lets say we wanna look for A, T, G, C and N composition1=letterFrequency(seq, letters=c(&quot;A&quot;,&quot;T&quot;, &quot;G&quot;, &quot;C&quot;, &quot;N&quot;)) print(composition1) ## A T G C N ## [1,] 79 97 82 40 88 ## [2,] 84 100 78 39 81 ## [3,] 80 98 82 40 85 ## [4,] 76 98 85 40 82 ## [5,] 82 99 81 40 90 ## [6,] 82 93 77 39 86 Computing the GC Content gc_content &lt;- letterFrequency(seq, letters=&quot;GC&quot;, as.prob=TRUE) gc_content ## G|C ## [1,] 0.1445498 ## [2,] 0.1389549 ## [3,] 0.1450654 ## [4,] 0.1498801 ## [5,] 0.1430260 ## [6,] 0.1389222 Calculate the mean of Gc content mean(gc_content) ## [1] 0.1433997 Standard deviation sd(gc_content) ## [1] 0.004148188 range(gc_content) ## [1] 0.1389222 0.1498801 Which GC has the maximum content seq[which(gc_content==max(gc_content))] ## DNAStringSet object of length 1: ## width seq names ## [1] 834 MVVVSSCVNTTRTGGYTNSSTRG...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... 8.2 Searching and Analyzing the strings A biologist can search for specific substrings within the sequences and analyze their positions and characteristics for instance; - Search for substrings- in this case we search for \"GAATTC\" substring. ECoR1=vcountPattern(&quot;GAATTC&quot;, seq) print(ECoR1) ## [1] 0 0 0 0 0 0 HindIII = vcountPattern(&quot;AAGTT&quot;, seq) print(HindIII) ## [1] 1 0 1 1 1 0 Finding the position of substrings HindIII_pos=vmatchPattern(&quot;AAGCT&quot;, seq) print(HindIII_pos) ## MIndex object of length 6 ## $Spike_SARS_CoV2_2019 ## IRanges object with 0 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## ## $Spike_SARS_CoV ## IRanges object with 0 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## ## $Spike_Bat_coronavirus_RaTG13 ## IRanges object with 0 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## ## ... ## &lt;3 more elements&gt; Translate # translate(seq[[2]]) #Check functions available methods(class = &quot;DNAStringSet&quot;) ## [1] ! ## [2] != ## [3] [ ## [4] [[ ## [5] [[&lt;- ## [6] [&lt;- ## [7] %in% ## [8] &lt; ## [9] &lt;= ## [10] == ## [11] &gt; ## [12] &gt;= ## [13] $ ## [14] $&lt;- ## [15] aggregate ## [16] alphabetFrequency ## [17] anyDuplicated ## [18] anyNA ## [19] append ## [20] as.character ## [21] as.complex ## [22] as.data.frame ## [23] as.env ## [24] as.factor ## [25] as.integer ## [26] as.list ## [27] as.logical ## [28] as.matrix ## [29] as.numeric ## [30] as.raw ## [31] as.vector ## [32] bindROWS ## [33] by ## [34] c ## [35] cbind ## [36] chartr ## [37] coerce ## [38] compact ## [39] compareStrings ## [40] complement ## [41] consensusMatrix ## [42] consensusString ## [43] countOverlaps ## [44] countPattern ## [45] countPDict ## [46] dinucleotideFrequencyTest ## [47] do.call ## [48] droplevels ## [49] duplicated ## [50] elementMetadata ## [51] elementMetadata&lt;- ## [52] elementNROWS ## [53] elementType ## [54] eval ## [55] expand ## [56] expand.grid ## [57] extractAt ## [58] extractROWS ## [59] FactorToClass ## [60] Filter ## [61] findOverlaps ## [62] getListElement ## [63] hasOnlyBaseLetters ## [64] head ## [65] ifelse2 ## [66] intersect ## [67] is.na ## [68] is.unsorted ## [69] isEmpty ## [70] isMatchingEndingAt ## [71] isMatchingStartingAt ## [72] lapply ## [73] length ## [74] lengths ## [75] letterFrequency ## [76] make_XStringSet_from_strings ## [77] match ## [78] matchPattern ## [79] matchPDict ## [80] mcols ## [81] mcols&lt;- ## [82] merge ## [83] mergeROWS ## [84] metadata ## [85] metadata&lt;- ## [86] mstack ## [87] names ## [88] names&lt;- ## [89] nchar ## [90] neditEndingAt ## [91] neditStartingAt ## [92] normalizeSingleBracketReplacementValue ## [93] nucleotideFrequencyAt ## [94] oligonucleotideFrequency ## [95] order ## [96] overlapsAny ## [97] PairwiseAlignments ## [98] PairwiseAlignmentsSingleSubject ## [99] palindromeArmLength ## [100] parallel_slot_names ## [101] parallelVectorNames ## [102] pcompare ## [103] pcompareRecursively ## [104] PDict ## [105] PWM ## [106] rank ## [107] rbind ## [108] Reduce ## [109] relist ## [110] relistToClass ## [111] rename ## [112] rep ## [113] rep.int ## [114] replaceAt ## [115] replaceLetterAt ## [116] replaceROWS ## [117] rev ## [118] revElements ## [119] reverse ## [120] reverseComplement ## [121] sapply ## [122] selfmatch ## [123] seqinfo ## [124] seqinfo&lt;- ## [125] seqlevelsInUse ## [126] seqtype ## [127] seqtype&lt;- ## [128] setdiff ## [129] setequal ## [130] setListElement ## [131] shiftApply ## [132] show ## [133] showAsCell ## [134] sort ## [135] split ## [136] split&lt;- ## [137] stack ## [138] stringDist ## [139] strsplit ## [140] subseq ## [141] subseq&lt;- ## [142] subset ## [143] subsetByOverlaps ## [144] summary ## [145] table ## [146] tail ## [147] tapply ## [148] threebands ## [149] toString ## [150] transform ## [151] translate ## [152] trimLRPatterns ## [153] twoWayAlphabetFrequency ## [154] union ## [155] unique ## [156] uniqueLetters ## [157] unlist ## [158] unname ## [159] unsplit ## [160] unstrsplit ## [161] updateObject ## [162] values ## [163] values&lt;- ## [164] vcountPattern ## [165] vcountPDict ## [166] vmatchPattern ## [167] vwhichPDict ## [168] which.isMatchingEndingAt ## [169] which.isMatchingStartingAt ## [170] whichPDict ## [171] width ## [172] window ## [173] window&lt;- ## [174] windows ## [175] with ## [176] within ## [177] xtabs ## [178] xtfrm ## [179] xvcopy ## [180] zipdown ## see &#39;?methods&#39; for accessing help and source code 8.3 Using seqinr Another useful library in sequence analysis is seqinr. After installing the library by invoking install.packages(\"seqinr\") to the console, load it to the workspace library(seqinr) ## ## Attaching package: &#39;seqinr&#39; ## The following object is masked from &#39;package:Biostrings&#39;: ## ## translate ## The following object is masked from &#39;package:dplyr&#39;: ## ## count Reading the fasta file containing the protein sequence using the read.fasta function. proseq = read.fasta(file=&quot;data/spike_multifasta.txt&quot;, seqtype=&quot;AA&quot;) str(proseq) ## List of 6 ## $ Spike_SARS_CoV2_2019 : &#39;SeqFastaAA&#39; chr [1:1273] &quot;M&quot; &quot;F&quot; &quot;V&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_SARS_CoV2_2019&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_SARS_CoV2_2019&quot; ## $ Spike_SARS_CoV : &#39;SeqFastaAA&#39; chr [1:1255] &quot;M&quot; &quot;F&quot; &quot;I&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_SARS_CoV&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_SARS_CoV&quot; ## $ Spike_Bat_coronavirus_RaTG13 : &#39;SeqFastaAA&#39; chr [1:1269] &quot;M&quot; &quot;F&quot; &quot;V&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_Bat_coronavirus_RaTG13&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_Bat_coronavirus_RaTG13&quot; ## $ Spike_Pangolin_coronavirus_GX: &#39;SeqFastaAA&#39; chr [1:1269] &quot;M&quot; &quot;F&quot; &quot;V&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_Pangolin_coronavirus_GX&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_Pangolin_coronavirus_GX&quot; ## $ Spike_Pangolin_coronavirus_GD: &#39;SeqFastaAA&#39; chr [1:1265] &quot;M&quot; &quot;L&quot; &quot;F&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_Pangolin_coronavirus_GD&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_Pangolin_coronavirus_GD&quot; ## $ Spike_WIV1_Bat_Coronovirus : &#39;SeqFastaAA&#39; chr [1:1256] &quot;M&quot; &quot;K&quot; &quot;L&quot; &quot;L&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_WIV1_Bat_Coronovirus&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_WIV1_Bat_Coronovirus&quot; Count the number of sequences num_seq = length(proseq) print(paste(&quot;Number of sequences = &quot;, num_seq)) ## [1] &quot;Number of sequences = 6&quot; Names of the sequences names=getName(proseq) names ## [1] &quot;Spike_SARS_CoV2_2019&quot; &quot;Spike_SARS_CoV&quot; ## [3] &quot;Spike_Bat_coronavirus_RaTG13&quot; &quot;Spike_Pangolin_coronavirus_GX&quot; ## [5] &quot;Spike_Pangolin_coronavirus_GD&quot; &quot;Spike_WIV1_Bat_Coronovirus&quot; Annotation of sequences annotation &lt;- getAnnot(proseq) annotation ## [[1]] ## [1] &quot;&gt;Spike_SARS_CoV2_2019&quot; ## ## [[2]] ## [1] &quot;&gt;Spike_SARS_CoV&quot; ## ## [[3]] ## [1] &quot;&gt;Spike_Bat_coronavirus_RaTG13&quot; ## ## [[4]] ## [1] &quot;&gt;Spike_Pangolin_coronavirus_GX&quot; ## ## [[5]] ## [1] &quot;&gt;Spike_Pangolin_coronavirus_GD&quot; ## ## [[6]] ## [1] &quot;&gt;Spike_WIV1_Bat_Coronovirus&quot; Length of individual sequences len_seq = getLength(proseq) len_seq ## [1] 1273 1255 1269 1269 1265 1256 Protein statistics print(AAstat(proseq[[1]])) ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 79 40 62 48 77 82 17 76 61 108 14 88 58 62 42 99 97 97 12 ## Y ## 54 ## ## $Prop ## $Prop$Tiny ## [1] 0.3118617 ## ## $Prop$Small ## [1] 0.5514533 ## ## $Prop$Aliphatic ## [1] 0.2207384 ## ## $Prop$Aromatic ## [1] 0.1256874 ## ## $Prop$Non.polar ## [1] 0.5475255 ## ## $Prop$Polar ## [1] 0.4524745 ## ## $Prop$Charged ## [1] 0.1806756 ## ## $Prop$Basic ## [1] 0.09426551 ## ## $Prop$Acidic ## [1] 0.08641005 ## ## ## $Pi ## [1] 6.236478 It gives the type of proteins for (i in 1:num_seq) { print(names[i]) print(AAstat(proseq[[i]])) } ## [1] &quot;Spike_SARS_CoV2_2019&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 79 40 62 48 77 82 17 76 61 108 14 88 58 62 42 99 97 97 12 ## Y ## 54 ## ## $Prop ## $Prop$Tiny ## [1] 0.3118617 ## ## $Prop$Small ## [1] 0.5514533 ## ## $Prop$Aliphatic ## [1] 0.2207384 ## ## $Prop$Aromatic ## [1] 0.1256874 ## ## $Prop$Non.polar ## [1] 0.5475255 ## ## $Prop$Polar ## [1] 0.4524745 ## ## $Prop$Charged ## [1] 0.1806756 ## ## $Prop$Basic ## [1] 0.09426551 ## ## $Prop$Acidic ## [1] 0.08641005 ## ## ## $Pi ## [1] 6.236478 ## ## [1] &quot;Spike_SARS_CoV&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 84 39 74 42 83 78 15 77 60 99 20 81 57 55 39 96 100 91 11 ## Y ## 54 ## ## $Prop ## $Prop$Tiny ## [1] 0.3163347 ## ## $Prop$Small ## [1] 0.5577689 ## ## $Prop$Aliphatic ## [1] 0.212749 ## ## $Prop$Aromatic ## [1] 0.1298805 ## ## $Prop$Non.polar ## [1] 0.5521912 ## ## $Prop$Polar ## [1] 0.4478088 ## ## $Prop$Charged ## [1] 0.1832669 ## ## $Prop$Basic ## [1] 0.09083665 ## ## $Prop$Acidic ## [1] 0.09243028 ## ## ## $Pi ## [1] 5.510607 ## ## [1] &quot;Spike_Bat_coronavirus_RaTG13&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 80 40 64 47 75 82 18 79 63 109 14 85 58 60 39 97 98 94 12 ## Y ## 55 ## ## $Prop ## $Prop$Tiny ## [1] 0.3128448 ## ## $Prop$Small ## [1] 0.5500394 ## ## $Prop$Aliphatic ## [1] 0.2222222 ## ## $Prop$Aromatic ## [1] 0.1260835 ## ## $Prop$Non.polar ## [1] 0.5500394 ## ## $Prop$Polar ## [1] 0.4499606 ## ## $Prop$Charged ## [1] 0.1820331 ## ## $Prop$Basic ## [1] 0.09456265 ## ## $Prop$Acidic ## [1] 0.08747045 ## ## ## $Pi ## [1] 6.11311 ## ## [1] &quot;Spike_Pangolin_coronavirus_GX&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 76 40 61 48 75 85 17 79 61 113 15 82 56 62 41 94 98 97 12 ## Y ## 55 ## ## $Prop ## $Prop$Tiny ## [1] 0.3096927 ## ## $Prop$Small ## [1] 0.5429472 ## ## $Prop$Aliphatic ## [1] 0.2277384 ## ## $Prop$Aromatic ## [1] 0.1252955 ## ## $Prop$Non.polar ## [1] 0.5539795 ## ## $Prop$Polar ## [1] 0.4444444 ## ## $Prop$Charged ## [1] 0.179669 ## ## $Prop$Basic ## [1] 0.09377463 ## ## $Prop$Acidic ## [1] 0.08589441 ## ## ## $Pi ## [1] 6.235931 ## ## [1] &quot;Spike_Pangolin_coronavirus_GD&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 82 40 60 48 76 81 14 80 58 103 15 90 54 58 40 100 99 95 12 ## Y ## 60 ## ## $Prop ## $Prop$Tiny ## [1] 0.3177866 ## ## $Prop$Small ## [1] 0.5541502 ## ## $Prop$Aliphatic ## [1] 0.2197628 ## ## $Prop$Aromatic ## [1] 0.1280632 ## ## $Prop$Non.polar ## [1] 0.5517787 ## ## $Prop$Polar ## [1] 0.4482213 ## ## $Prop$Charged ## [1] 0.173913 ## ## $Prop$Basic ## [1] 0.08853755 ## ## $Prop$Acidic ## [1] 0.08537549 ## ## ## $Pi ## [1] 5.900948 ## ## [1] &quot;Spike_WIV1_Bat_Coronovirus&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 82 39 72 43 83 77 15 77 60 102 17 86 62 54 42 98 93 93 11 ## Y ## 50 ## ## $Prop ## $Prop$Tiny ## [1] 0.3097134 ## ## $Prop$Small ## [1] 0.5589172 ## ## $Prop$Aliphatic ## [1] 0.2165605 ## ## $Prop$Aromatic ## [1] 0.1265924 ## ## $Prop$Non.polar ## [1] 0.5517516 ## ## $Prop$Polar ## [1] 0.4482484 ## ## $Prop$Charged ## [1] 0.1847134 ## ## $Prop$Basic ## [1] 0.09315287 ## ## $Prop$Acidic ## [1] 0.09156051 ## ## ## $Pi ## [1] 5.739146 Show commands in seqinr lseqinr() ## [1] &quot;a&quot; &quot;aaa&quot; ## [3] &quot;AAstat&quot; &quot;acnucclose&quot; ## [5] &quot;acnucopen&quot; &quot;al2bp&quot; ## [7] &quot;alllistranks&quot; &quot;alr&quot; ## [9] &quot;amb&quot; &quot;as.alignment&quot; ## [11] &quot;as.matrix.alignment&quot; &quot;as.SeqAcnucWeb&quot; ## [13] &quot;as.SeqFastaAA&quot; &quot;as.SeqFastadna&quot; ## [15] &quot;as.SeqFrag&quot; &quot;autosocket&quot; ## [17] &quot;baselineabif&quot; &quot;bma&quot; ## [19] &quot;c2s&quot; &quot;cai&quot; ## [21] &quot;cfl&quot; &quot;choosebank&quot; ## [23] &quot;circle&quot; &quot;clfcd&quot; ## [25] &quot;clientid&quot; &quot;closebank&quot; ## [27] &quot;col2alpha&quot; &quot;comp&quot; ## [29] &quot;computePI&quot; &quot;con&quot; ## [31] &quot;consensus&quot; &quot;count&quot; ## [33] &quot;countfreelists&quot; &quot;countsubseqs&quot; ## [35] &quot;crelistfromclientdata&quot; &quot;css&quot; ## [37] &quot;dia.bactgensize&quot; &quot;dia.db.growth&quot; ## [39] &quot;dist.alignment&quot; &quot;dotchart.uco&quot; ## [41] &quot;dotPlot&quot; &quot;draw.oriloc&quot; ## [43] &quot;draw.rearranged.oriloc&quot; &quot;draw.recstat&quot; ## [45] &quot;exseq&quot; &quot;extract.breakpoints&quot; ## [47] &quot;extractseqs&quot; &quot;fastacc&quot; ## [49] &quot;gb2fasta&quot; &quot;gbk2g2&quot; ## [51] &quot;gbk2g2.euk&quot; &quot;GC&quot; ## [53] &quot;GC1&quot; &quot;GC2&quot; ## [55] &quot;GC3&quot; &quot;GCpos&quot; ## [57] &quot;get.db.growth&quot; &quot;getAnnot&quot; ## [59] &quot;getAnnot.default&quot; &quot;getAnnot.list&quot; ## [61] &quot;getAnnot.logical&quot; &quot;getAnnot.qaw&quot; ## [63] &quot;getAnnot.SeqAcnucWeb&quot; &quot;getAnnot.SeqFastaAA&quot; ## [65] &quot;getAnnot.SeqFastadna&quot; &quot;getAttributsocket&quot; ## [67] &quot;getFrag&quot; &quot;getFrag.character&quot; ## [69] &quot;getFrag.default&quot; &quot;getFrag.list&quot; ## [71] &quot;getFrag.logical&quot; &quot;getFrag.qaw&quot; ## [73] &quot;getFrag.SeqAcnucWeb&quot; &quot;getFrag.SeqFastaAA&quot; ## [75] &quot;getFrag.SeqFastadna&quot; &quot;getFrag.SeqFrag&quot; ## [77] &quot;getKeyword&quot; &quot;getKeyword.default&quot; ## [79] &quot;getKeyword.list&quot; &quot;getKeyword.logical&quot; ## [81] &quot;getKeyword.qaw&quot; &quot;getKeyword.SeqAcnucWeb&quot; ## [83] &quot;getLength&quot; &quot;getLength.character&quot; ## [85] &quot;getLength.default&quot; &quot;getLength.list&quot; ## [87] &quot;getLength.logical&quot; &quot;getLength.qaw&quot; ## [89] &quot;getLength.SeqAcnucWeb&quot; &quot;getLength.SeqFastaAA&quot; ## [91] &quot;getLength.SeqFastadna&quot; &quot;getLength.SeqFrag&quot; ## [93] &quot;getlistrank&quot; &quot;getliststate&quot; ## [95] &quot;getLocation&quot; &quot;getLocation.default&quot; ## [97] &quot;getLocation.list&quot; &quot;getLocation.logical&quot; ## [99] &quot;getLocation.qaw&quot; &quot;getLocation.SeqAcnucWeb&quot; ## [101] &quot;getName&quot; &quot;getName.default&quot; ## [103] &quot;getName.list&quot; &quot;getName.logical&quot; ## [105] &quot;getName.qaw&quot; &quot;getName.SeqAcnucWeb&quot; ## [107] &quot;getName.SeqFastaAA&quot; &quot;getName.SeqFastadna&quot; ## [109] &quot;getName.SeqFrag&quot; &quot;getNumber.socket&quot; ## [111] &quot;getSequence&quot; &quot;getSequence.character&quot; ## [113] &quot;getSequence.default&quot; &quot;getSequence.list&quot; ## [115] &quot;getSequence.logical&quot; &quot;getSequence.qaw&quot; ## [117] &quot;getSequence.SeqAcnucWeb&quot; &quot;getSequence.SeqFastaAA&quot; ## [119] &quot;getSequence.SeqFastadna&quot; &quot;getSequence.SeqFrag&quot; ## [121] &quot;getTrans&quot; &quot;getTrans.character&quot; ## [123] &quot;getTrans.default&quot; &quot;getTrans.list&quot; ## [125] &quot;getTrans.logical&quot; &quot;getTrans.qaw&quot; ## [127] &quot;getTrans.SeqAcnucWeb&quot; &quot;getTrans.SeqFastadna&quot; ## [129] &quot;getTrans.SeqFrag&quot; &quot;getType&quot; ## [131] &quot;gfrag&quot; &quot;ghelp&quot; ## [133] &quot;gln&quot; &quot;glr&quot; ## [135] &quot;gls&quot; &quot;is.SeqAcnucWeb&quot; ## [137] &quot;is.SeqFastaAA&quot; &quot;is.SeqFastadna&quot; ## [139] &quot;is.SeqFrag&quot; &quot;isenum&quot; ## [141] &quot;isn&quot; &quot;kaks&quot; ## [143] &quot;kdb&quot; &quot;knowndbs&quot; ## [145] &quot;lseqinr&quot; &quot;modifylist&quot; ## [147] &quot;move&quot; &quot;mv&quot; ## [149] &quot;n2s&quot; &quot;oriloc&quot; ## [151] &quot;parser.socket&quot; &quot;peakabif&quot; ## [153] &quot;permutation&quot; &quot;pga&quot; ## [155] &quot;plot.SeqAcnucWeb&quot; &quot;plotabif&quot; ## [157] &quot;plotladder&quot; &quot;plotPanels&quot; ## [159] &quot;pmw&quot; &quot;prepgetannots&quot; ## [161] &quot;prettyseq&quot; &quot;print.qaw&quot; ## [163] &quot;print.SeqAcnucWeb&quot; &quot;query&quot; ## [165] &quot;quitacnuc&quot; &quot;read.abif&quot; ## [167] &quot;read.alignment&quot; &quot;read.fasta&quot; ## [169] &quot;readBins&quot; &quot;readfirstrec&quot; ## [171] &quot;readPanels&quot; &quot;readsmj&quot; ## [173] &quot;rearranged.oriloc&quot; &quot;recstat&quot; ## [175] &quot;residuecount&quot; &quot;reverse.align&quot; ## [177] &quot;rho&quot; &quot;rot13&quot; ## [179] &quot;s2c&quot; &quot;s2n&quot; ## [181] &quot;savelist&quot; &quot;SEQINR.UTIL&quot; ## [183] &quot;setlistname&quot; &quot;splitseq&quot; ## [185] &quot;stresc&quot; &quot;stutterabif&quot; ## [187] &quot;summary.SeqFastaAA&quot; &quot;summary.SeqFastadna&quot; ## [189] &quot;swap&quot; &quot;syncodons&quot; ## [191] &quot;synsequence&quot; &quot;tablecode&quot; ## [193] &quot;test.co.recstat&quot; &quot;test.li.recstat&quot; ## [195] &quot;translate&quot; &quot;trimSpace&quot; ## [197] &quot;uco&quot; &quot;ucoweight&quot; ## [199] &quot;where.is.this.acc&quot; &quot;words&quot; ## [201] &quot;words.pos&quot; &quot;write.fasta&quot; ## [203] &quot;zscore&quot; 8.4 Using Short Read This library can be installed by invoking the BiocManager::install(\"ShortRead\") command to the console. load the library library(ShortRead) ## Loading required package: BiocParallel ## Loading required package: Rsamtools ## Loading required package: GenomicRanges ## Loading required package: GenomicAlignments ## Loading required package: SummarizedExperiment ## Loading required package: MatrixGenerics ## Loading required package: matrixStats ## ## Attaching package: &#39;matrixStats&#39; ## The following object is masked from &#39;package:seqinr&#39;: ## ## count ## The following object is masked from &#39;package:dplyr&#39;: ## ## count ## ## Attaching package: &#39;MatrixGenerics&#39; ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, ## colCounts, colCummaxs, colCummins, colCumprods, colCumsums, ## colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, ## colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, ## colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, ## colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, ## colWeightedMeans, colWeightedMedians, colWeightedSds, ## colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, ## rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, ## rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, ## rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, ## rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, ## rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, ## rowWeightedMads, rowWeightedMeans, rowWeightedMedians, ## rowWeightedSds, rowWeightedVars ## Loading required package: Biobase ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## ## Attaching package: &#39;Biobase&#39; ## The following object is masked from &#39;package:MatrixGenerics&#39;: ## ## rowMedians ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## anyMissing, rowMedians ## ## Attaching package: &#39;GenomicAlignments&#39; ## The following object is masked from &#39;package:data.table&#39;: ## ## last ## The following object is masked from &#39;package:dplyr&#39;: ## ## last ## ## Attaching package: &#39;ShortRead&#39; ## The following object is masked from &#39;package:data.table&#39;: ## ## tables ## The following object is masked from &#39;package:dplyr&#39;: ## ## id Reading the fastq sequences fq = readFastq(&quot;data/file2.fastq&quot;) fq ## class: ShortReadQ ## length: 5 reads; width: 149..166 cycles Preview of first 3 sequences fq[1:3] ## class: ShortReadQ ## length: 3 reads; width: 149 161 cycles Sequence information sread(fq) ## DNAStringSet object of length 5: ## width seq ## [1] 149 CGCAAGCGAGTTAAGCAGTCTGTCCAAAGCATGT...TTATCCACATCTGTCATGACGATTTCGTTTGAT ## [2] 161 CGTTATCAGAGAGCTCTTGTCGCAAGCGAGTTAA...CTACCAAGTTATCCACATCTGTCATGACGATTT ## [3] 161 AGCGAGTTAAGCAGTCTGTCCAAAGCATGTGTAT...GACGATTTCGTTTGATTTTGCCTTAAAAAGAAA ## [4] 166 GACCCCTTCTCATCAGGAAGGGTTAATCTTTAAA...TGGATTCGCCCTTTAGTAGCTGAAGAAGTAGAG ## [5] 166 CCCCTTCTCATCAGGAAGGGTTAATCTTTAAATG...GATTCGCCCTTTAGTAGCTGAAGAAGTAGAGGG Subset the sequence from second to fifth sread(fq[2:5]) ## DNAStringSet object of length 4: ## width seq ## [1] 161 CGTTATCAGAGAGCTCTTGTCGCAAGCGAGTTAA...CTACCAAGTTATCCACATCTGTCATGACGATTT ## [2] 161 AGCGAGTTAAGCAGTCTGTCCAAAGCATGTGTAT...GACGATTTCGTTTGATTTTGCCTTAAAAAGAAA ## [3] 166 GACCCCTTCTCATCAGGAAGGGTTAATCTTTAAA...TGGATTCGCCCTTTAGTAGCTGAAGAAGTAGAG ## [4] 166 CCCCTTCTCATCAGGAAGGGTTAATCTTTAAATG...GATTCGCCCTTTAGTAGCTGAAGAAGTAGAGGG Inspect the quality of the sequence quality(fq) ## class: FastqQuality ## quality: ## BStringSet object of length 5: ## width seq ## [1] 149 CCCC&gt;CHDBBC&lt;=8=DCCCDDDCB&gt;BG?GGEDB=...C@B==8=CDDDDDDDDDC==&lt;C@C8&lt;&lt;DD=BCE ## [2] 161 &lt;CE:@C=&lt;&lt;=DDDCBBC&gt;&lt;&lt;&lt;CDD&gt;BCEHGI&gt;C&gt;...999929-39:&gt;BE&gt;BBA@ADEC?&gt;?AAA999C; ## [3] 161 DDEDEEEAE@DD=&gt;=:==BB?BG&gt;FDEDCCBBBB...D&gt;///99*//::4:&lt;BBB6BD-2--555-5::: ## [4] 166 CCCLL;E@DE&gt;&gt;=DDDAE@EEBE@@?CCEE?EE?...BB@DDAD8884;C&lt;CFGGE?@?C?CC=BDEEEA ## [5] 166 666/6:::=BBCCBACADD6@:D@DDEE&gt;DD&gt;DE...&gt;BDAC58;6:D&gt;DDDDGEEBB&lt;CD@DDDEEED&gt; Number of sequence in the file length(fq) ## [1] 5 Length of reads readLength = width(fq) readLength ## [1] 149 161 161 166 166 generating the summary of fasta sequences fq_reads = sread(fq) id_of_reads=id(fq) id_of_reads[1:5] ## BStringSet object of length 5: ## width seq ## [1] 17 OLVOG:01110:02677 ## [2] 17 OLVOG:01219:01823 ## [3] 17 OLVOG:01240:02825 ## [4] 17 OLVOG:02464:02160 ## [5] 17 OLVOG:02703:02334 fq_reads ## DNAStringSet object of length 5: ## width seq ## [1] 149 CGCAAGCGAGTTAAGCAGTCTGTCCAAAGCATGT...TTATCCACATCTGTCATGACGATTTCGTTTGAT ## [2] 161 CGTTATCAGAGAGCTCTTGTCGCAAGCGAGTTAA...CTACCAAGTTATCCACATCTGTCATGACGATTT ## [3] 161 AGCGAGTTAAGCAGTCTGTCCAAAGCATGTGTAT...GACGATTTCGTTTGATTTTGCCTTAAAAAGAAA ## [4] 166 GACCCCTTCTCATCAGGAAGGGTTAATCTTTAAA...TGGATTCGCCCTTTAGTAGCTGAAGAAGTAGAG ## [5] 166 CCCCTTCTCATCAGGAAGGGTTAATCTTTAAATG...GATTCGCCCTTTAGTAGCTGAAGAAGTAGAGGG Seq length - we can generate the sequence lenght by converting it to a dataframe seq_length = as.data.frame(fq_reads@ranges@width) seq_length ## fq_reads@ranges@width ## 1 149 ## 2 161 ## 3 161 ## 4 166 ## 5 166 Quality scores quality_scores=quality(fq) quality_scores[1:5] ## class: FastqQuality ## quality: ## BStringSet object of length 5: ## width seq ## [1] 149 CCCC&gt;CHDBBC&lt;=8=DCCCDDDCB&gt;BG?GGEDB=...C@B==8=CDDDDDDDDDC==&lt;C@C8&lt;&lt;DD=BCE ## [2] 161 &lt;CE:@C=&lt;&lt;=DDDCBBC&gt;&lt;&lt;&lt;CDD&gt;BCEHGI&gt;C&gt;...999929-39:&gt;BE&gt;BBA@ADEC?&gt;?AAA999C; ## [3] 161 DDEDEEEAE@DD=&gt;=:==BB?BG&gt;FDEDCCBBBB...D&gt;///99*//::4:&lt;BBB6BD-2--555-5::: ## [4] 166 CCCLL;E@DE&gt;&gt;=DDDAE@EEBE@@?CCEE?EE?...BB@DDAD8884;C&lt;CFGGE?@?C?CC=BDEEEA ## [5] 166 666/6:::=BBCCBACADD6@:D@DDEE&gt;DD&gt;DE...&gt;BDAC58;6:D&gt;DDDDGEEBB&lt;CD@DDDEEED&gt; Convert the scores to matrix and see as real numbers scores=as(quality_scores, &quot;matrix&quot;) scores ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] ## [1,] 34 34 34 34 29 34 39 35 33 33 34 27 28 23 ## [2,] 27 34 36 25 31 34 28 27 27 28 35 35 35 34 ## [3,] 35 35 36 35 36 36 36 32 36 31 35 35 28 29 ## [4,] 34 34 34 43 43 26 36 31 35 36 29 29 28 35 ## [5,] 21 21 21 14 21 25 25 25 28 33 33 34 34 33 ## [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] ## [1,] 28 35 34 34 34 35 35 35 34 33 29 33 ## [2,] 33 33 34 29 27 27 27 34 35 35 29 33 ## [3,] 28 25 28 28 33 33 30 33 38 29 37 35 ## [4,] 35 35 32 36 31 36 36 33 36 31 31 30 ## [5,] 32 34 32 35 35 21 31 25 35 31 35 35 ## [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] ## [1,] 38 30 38 38 36 35 33 28 28 28 35 36 ## [2,] 34 36 39 38 40 29 34 29 34 37 28 28 ## [3,] 36 35 34 34 33 33 33 33 33 34 33 25 ## [4,] 34 34 36 36 30 36 36 30 35 35 27 27 ## [5,] 36 36 29 35 35 29 35 36 35 35 36 30 ## [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50] ## [1,] 38 38 38 26 37 34 34 34 34 34 33 34 ## [2,] 29 35 34 34 32 34 23 28 28 25 28 35 ## [3,] 33 35 35 35 35 35 35 34 34 28 28 28 ## [4,] 21 16 25 30 25 30 33 30 34 40 37 26 ## [5,] 36 36 32 36 36 31 36 36 36 26 35 36 ## [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62] ## [1,] 34 30 33 33 33 25 33 36 30 37 31 35 ## [2,] 35 36 36 34 33 33 33 33 33 33 33 25 ## [3,] 28 21 26 34 23 32 26 23 23 18 14 25 ## [4,] 33 30 30 36 36 36 36 27 20 27 35 36 ## [5,] 36 36 35 35 35 28 28 28 35 35 35 26 ## [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74] ## [1,] 35 36 30 35 35 28 27 27 23 27 35 28 ## [2,] 33 30 30 27 28 27 25 25 34 25 25 25 ## [3,] 33 25 25 25 14 15 28 21 28 27 28 21 ## [4,] 36 26 35 33 34 34 35 36 35 35 35 36 ## [5,] 35 34 35 35 35 36 35 35 35 37 36 36 ## [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86] ## [1,] 35 35 35 26 32 19 25 18 25 23 29 26 ## [2,] 25 14 25 25 14 25 26 32 32 36 30 34 ## [3,] 27 9 13 9 12 16 20 8 24 25 35 35 ## [4,] 35 35 30 36 32 35 35 35 35 35 35 35 ## [5,] 29 36 32 35 35 35 34 35 34 36 35 35 ## [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98] ## [1,] 34 35 36 37 33 33 33 34 32 37 40 38 ## [2,] 34 31 30 29 14 25 25 14 25 34 34 32 ## [3,] 35 35 34 35 29 34 34 33 19 31 31 24 ## [4,] 35 35 35 30 34 31 35 35 35 35 35 35 ## [5,] 35 30 34 31 35 35 35 35 34 34 31 36 ## [,99] [,100] [,101] [,102] [,103] [,104] [,105] [,106] [,107] [,108] ## [1,] 26 34 34 35 35 30 34 35 26 32 ## [2,] 34 17 24 24 13 24 17 24 28 34 ## [3,] 18 12 18 18 12 17 23 17 17 12 ## [4,] 32 36 35 35 35 34 34 30 34 36 ## [5,] 35 35 36 35 36 28 33 33 33 33 ## [,109] [,110] [,111] [,112] [,113] [,114] [,115] [,116] [,117] [,118] ## [1,] 32 25 25 25 23 28 33 35 34 31 ## [2,] 33 32 33 36 36 35 36 23 26 26 ## [3,] 17 16 23 23 25 32 33 33 26 21 ## [4,] 35 35 35 35 35 32 33 33 35 35 ## [5,] 34 32 32 32 34 34 34 35 35 28 ## [,119] [,120] [,121] [,122] [,123] [,124] [,125] [,126] [,127] [,128] ## [1,] 33 28 28 23 28 34 35 35 35 35 ## [2,] 26 12 24 31 30 29 24 30 29 23 ## [3,] 21 24 32 35 36 33 33 33 33 33 ## [4,] 35 30 34 34 35 35 35 35 29 36 ## [5,] 32 33 35 33 33 33 28 33 35 35 ## [,129] [,130] [,131] [,132] [,133] [,134] [,135] [,136] [,137] [,138] ## [1,] 35 35 35 35 35 34 28 28 27 34 ## [2,] 24 24 24 24 17 24 12 18 24 25 ## [3,] 35 29 14 14 14 24 24 9 14 14 ## [4,] 35 35 34 34 33 33 33 31 35 35 ## [5,] 35 35 35 33 33 29 33 35 32 34 ## [,139] [,140] [,141] [,142] [,143] [,144] [,145] [,146] [,147] [,148] ## [1,] 31 34 23 27 27 35 35 28 33 34 ## [2,] 29 33 36 29 33 33 32 31 32 35 ## [3,] 25 25 19 25 27 33 33 33 21 33 ## [4,] 32 35 23 23 23 19 26 34 27 34 ## [5,] 20 23 26 21 25 35 29 35 35 35 ## [,149] [,150] [,151] [,152] [,153] [,154] [,155] [,156] [,157] [,158] ## [1,] 36 NA NA NA NA NA NA NA NA NA ## [2,] 36 34 30 29 30 32 32 32 24 24 ## [3,] 35 12 17 12 12 20 20 20 12 20 ## [4,] 37 38 38 36 30 31 30 34 30 34 ## [5,] 35 38 36 36 33 33 27 34 35 31 ## [,159] [,160] [,161] [,162] [,163] [,164] [,165] [,166] ## [1,] NA NA NA NA NA NA NA NA ## [2,] 24 34 26 NA NA NA NA NA ## [3,] 25 25 25 NA NA NA NA NA ## [4,] 34 28 33 35 36 36 36 32 ## [5,] 35 35 35 36 36 36 35 29 Mean score for each sequence mean_score_for_each_sequence = rowMeans(scores, na.rm=TRUE) mean_score_for_each_sequence ## [1] 32.00000 29.18012 26.57764 32.99398 32.71084 Mean score for each position mean_score_for_each_position = rowMeans(scores, na.rm=TRUE) mean_score_for_each_position ## [1] 32.00000 29.18012 26.57764 32.99398 32.71084 Plot a boxplot for the scores boxplot(scores, xlab=&quot;Position&quot;, ylab=&quot;Phred score&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
