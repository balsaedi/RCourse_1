[["index.html", "R Course Chapter 1 R Course", " R Course YOUR NAME HERE 2024-04-22 Chapter 1 R Course "],["r---introduction.html", "Chapter 2 R - Introduction 2.1 R - Basic Concepts and applications 2.2 Why R? 2.3 R studio 2.4 Basic Mathematics like operators 2.5 R Markdown 2.6 Installation of packages", " Chapter 2 R - Introduction 2.1 R - Basic Concepts and applications R (programming language) is a language and environment for statistical computing and graphics &lt;– logo image for Rstudio –&gt; 2.2 Why R? Developed by Statisticians - R is Excellent for Statistical Computing and Analysis Open-source (Free) - R is an open-source programming language. Anyone can work with R without any license or fee. Due to this, R has a huge community that contributes to its environment. A Large Variety of Specialized Libraries - These libraries support and enhance the R development environment. R Studio - A graphic user interface to R - easier to grasp and learn. Cross-platform Support - R is machine-independent. It supports the cross-platform operation. Thus, it is usable on many different operating systems. Can do Data Cleansing, Data Wrangling, and Web Scraping - R can collect data from the internet through web scraping and other means. It can also perform data cleansing. R is also useful for data wrangling which is the process of converting raw data into the desired format for easier consumption. Powerful Graphics - R has extensive libraries that can produce production quality graphs and visualizations. Compatible with other Programming Languages - R is compatible with other languages like C, C++, and FORTRAN. Other languages like .NET, Java, Python can also directly manipulate objects. Compatible with high performance computing and Big Data Analytics. 2.3 R studio Rstudio is an integrated development environment(IDE) for R. It includes a console, syntax-highlighting editor that supports direct code execution as well as tools for plotting history, debugging and work space management. RStudio - installation link &lt;-link in the first 7 minutes-&gt; Outline the process of creating and running R script - a screenshot &lt;–Check R Version –&gt; 2.3.1 R - Look and Feel &lt;– R screenshot image from the terminal–&gt; &lt;– default screenshot image for R Studio –&gt; explain each section/quadrant - text editor - stand input/output (console/terminal/jobs) - all data and its properties quadrants - plots and file directory structure 2.4 Basic Mathematics like operators Addition - the + operator is used to add two or more values 2+3 ## [1] 5 Subtraction - the - operator is used to subtract two numerical values 6-2 ## [1] 4 &lt;– add more content for operators–&gt; 2.5 R Markdown &lt;– Definition of R Markdown –&gt; &lt;–Introduce how to create R markdown file using screenshots –&gt; Each chunk can be run separately in a single file, also the variable in one chunk can be reused by the next/later chunks Anything added outside the chuck will not be executed in the program The R markdown can be knitted to a html, pdf, or word file &lt;–Include screenshots–&gt; 2.6 Installation of packages "],["data-types-and-data-structures.html", "Chapter 3 Data Types and Data Structures 3.1 Data types 3.2 Data Structures", " Chapter 3 Data Types and Data Structures 3.1 Data types &lt;– add more explanations to each data types –&gt; Numeric a=23.5 class(a) #check the data type of a ## [1] &quot;numeric&quot; Integers a=23L #add L to show it is an integer class(a) ## [1] &quot;integer&quot; Characters a=&quot;DNA&quot; class(a) ## [1] &quot;character&quot; Logical a=TRUE #logical data types is either TRUE or FALSE only class(a) ## [1] &quot;logical&quot; Complex, a=2+3i # Complex data types have &#39;i&#39; at the end of each number class(a) ## [1] &quot;complex&quot; Raw a=charToRaw(&quot;DNA&quot;) print(a) ## [1] 44 4e 41 class(a) ## [1] &quot;raw&quot; # convert back to character b=rawToChar(a) class(b) ## [1] &quot;character&quot; 3.2 Data Structures This is the organization of data into one or multiple data values in specific structures. Different types of data structures in R include; - Vector - Matrix - Data frame 3.2.1 Vector A vector is a single entity consisting of a collection of things. Here is an example of a vector. marks = c(23, 67, 98, 34, 98, 21) print(marks) ## [1] 23 67 98 34 98 21 The class function is utilized to determine the data types present within vector data values. class(marks) ## [1] &quot;numeric&quot; The vector “marks” consist of only numeric values is.vector function is used to check if the variable is a vector is.vector(marks) ## [1] TRUE unlike matrix and data frame, vector has no dimension dim(marks) ## NULL length() function is used to count number of elements in vectors length(marks) ## [1] 6 Index is the position of an element in a vector, in R it starts at index 1 - lets say we find the third element by index 3 marks[3] ## [1] 98 value “98” is at index 3, or the third in the vector. Vectors can be sliced to obtain values over a range of indices. For instance the code below shows how to retrieve the from the second to the fourth values as a vector print(marks[2:4]) ## [1] 67 98 34 is.vector(marks[2:4]) # confirm if the retrieved values are in a vector ## [1] TRUE An element at a specific index in a vector can be excluded by adding a - sign before the index value. marks[-2] #exclude the element at index 2 ## [1] 23 98 34 98 21 rev() command is used to reverse the order of elements in a vector rev(marks) ## [1] 21 98 34 98 67 23 3.2.1.1 Mathematical Operations in a vector The summary/descriptive statistics are calculated by summary() command. summary(marks) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 21.00 25.75 50.50 56.83 90.25 98.00 sum(), median(), and mean() are used to calculate the total, median, average and the standard deviation of the values in a vector print(&quot;MARKS&quot;) ## [1] &quot;MARKS&quot; print(paste(&quot;TOTAL: &quot;, sum(marks))) ## [1] &quot;TOTAL: 341&quot; print(paste(&quot;MEDIAN: &quot;, median(marks))) ## [1] &quot;MEDIAN: 50.5&quot; print(paste(&quot;AVERAGE: &quot;, mean(marks))) ## [1] &quot;AVERAGE: 56.8333333333333&quot; vector multiplication double_marks =2 * marks marks ## [1] 23 67 98 34 98 21 double_marks ## [1] 46 134 196 68 196 42 Vector division - divide the marks by 2 half_marks = marks/2 half_marks ## [1] 11.5 33.5 49.0 17.0 49.0 10.5 Multiply 2 vectors of equal length a = c(3, 5, 1) b = c(7, 3, 9) ab = a*b ab ## [1] 21 15 9 ba = b*a # is the same as ab ba ## [1] 21 15 9 Divide 2 vectors of equal length # Divide vector a by b abdiv=a/b abdiv ## [1] 0.4285714 1.6666667 0.1111111 # Divide vector b by a badiv=b/a badiv ## [1] 2.333333 0.600000 9.000000 However, when multiplying vectors of unequal length the shorter one is replicated to match the longer vector. It will then return a warning e=c(1,2,3,4,5) f=c(1,2) ef = e*f #it shows an error ## Warning in e * f: longer object length is not a multiple of shorter object ## length ef #shows results since f is replicated to match e as f=c(1,2,1,2,1) ## [1] 1 4 3 8 5 Multiple vectors can be concatenated/combined to come up with one giant vector a ## [1] 3 5 1 b ## [1] 7 3 9 z=c(a,b,a) #concatenates the vectors z ## [1] 3 5 1 7 3 9 3 5 1 3.2.1.2 Character Vectors Vectors can also contain character data types for instance my_name = c(&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;Vipin&quot;) my_name[5] = &quot;Singh&quot; #insert at the end my_name ## [1] &quot;My&quot; &quot;name&quot; &quot;is&quot; &quot;Vipin&quot; &quot;Singh&quot; Combining the vectors to a single string print(paste(my_name, collapse=&quot; &quot;)) ## [1] &quot;My name is Vipin Singh&quot; Calculate the summary/descriptive statistics of the vector by function summary(). It finds; - Count/length - Class (data type) - Mode summary(my_name) ## Length Class Mode ## 5 character character 3.2.1.3 Vectors with mixed data types A vector can also consist of characters values and numeric values for instance numbers=c(1,&quot;two&quot;, 3, &quot;three&quot;) numbers ## [1] &quot;1&quot; &quot;two&quot; &quot;3&quot; &quot;three&quot; however the numeric elements in the vector are recognized by R as character data type. They can be converted to numeric by; as.numeric(numbers[1]) + 2 ## [1] 3 the integers can be converted by; as.integer(numbers[1]) ## [1] 1 3.2.1.4 Named Vectors Variable names can be assigned to vectors like; named_vector=c(EcoR1=&quot;GAATTC&quot;, HindIII=&quot;AAGCTT&quot;, Pst1=&quot;CTGCAG&quot;) named_vector ## EcoR1 HindIII Pst1 ## &quot;GAATTC&quot; &quot;AAGCTT&quot; &quot;CTGCAG&quot; to access the names of the values is; names(named_vector) ## [1] &quot;EcoR1&quot; &quot;HindIII&quot; &quot;Pst1&quot; A vector element can be accessed using its name named_vector[&quot;EcoR1&quot;] # find the value of a vector by its name ## EcoR1 ## &quot;GAATTC&quot; 3.2.1.5 Generating number series as vectors The seq function in R is used to generate sequences of numbers. It takes several arguments, including from, to, by, and length.out, among others, to specify the range and increment of the sequence. Here’s a brief overview of its usage: from: The starting value of the sequence. to: The end value of the sequence. # Generate a sequence from 1 to 10 series = seq(from=1, to=20) series ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # It can also be written as series = seq(1,20) series ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class(series) ## [1] &quot;integer&quot; by: The increment between consecutive values in the sequence. # generate numbers 0 to 10 incremented by 0.5 series3=seq(0, 10, by=0.5) series3 ## [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 ## [16] 7.5 8.0 8.5 9.0 9.5 10.0 length: The desired length of the sequence. # generate 10 numbers from 0 to 6 series4=seq(0, 6, length=10) series4 ## [1] 0.0000000 0.6666667 1.3333333 2.0000000 2.6666667 3.3333333 4.0000000 ## [8] 4.6666667 5.3333333 6.0000000 seq(0, 6) ## [1] 0 1 2 3 4 5 6 along.with: An optional vector argument specifying the length and names of the output sequence. # Generate a sequence along with a vector seq(along.with = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] 1 2 3 3.2.1.6 Null data points in vectors NA data (Not available or blank) for instance marks=c(78,65, 98, 87, 89, NA) sum(is.na(marks)) #Count the null values in a vector ## [1] 1 Other inbuilt functions for mathematical operations cannot be done if Null values exists in a vector unless they are removed/ignored #sum(marks) #returns an error sum(marks, na.rm = TRUE) #remove null values before calculating the sum ## [1] 417 median(marks, na.rm = TRUE) ## [1] 87 summary(marks, na.rm = TRUE) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 65.0 78.0 87.0 83.4 89.0 98.0 1 3.2.2 Matrix A matrix is a two dimensional data type that contain a single class of data. The code below shows one can produce a matrix from a vector vector1 = seq(1, 9) # Convert to matrix ## create by column data1=matrix(vector1, ncol=3) data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 A vector of values 1 to 9 is being converted to a matrix where the values are being arranged columnwise by default. A matrix has a multiple dimensions, the most common type of matrix is two dimesnional. dim(data1) ## [1] 3 3 is.matrix() function is used to confirm if a given variable is a matrix and it return a boolean value. is.matrix(data1) ## [1] TRUE A matrix can also be created row-wise from a vector. ## create by row data2=matrix(vector1, ncol=3, byrow=TRUE) data2 # is a transpose of data1 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Matrix is recognized either as a matrix or array by R class(data1) ## [1] &quot;matrix&quot; &quot;array&quot; To access a specific data point in a matrix, the matrix is indexed by row then column for instance matrix_data[row_index, column_index] data1[3, 2] ## [1] 6 To access a single row, in this case we find the second row which will be returned as a vector data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 row2 = data1[2,] # access row 2 is.vector(row2) #can be accessed by row 2 ## [1] TRUE To access a single column data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 col3=data1[,3] # access column 3 is.vector(col3) #can be accessed by column 3 ## [1] TRUE Count the number of rows in a matrix nrow(data1) ## [1] 3 data1 has 3 rows Count the number of columns in a matrix ncol(data1) ## [1] 3 3.2.2.1 Mathematical Operations in a matrix Matrix Addition data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 data2 = data1 + 3 data2 ## [,1] [,2] [,3] ## [1,] 4 7 10 ## [2,] 5 8 11 ## [3,] 6 9 12 Adding value 3 to a matrix adds each value in the matrix by 3 Matrix Subtraction data3 = data1-1 #reduce each value by 1 data3 ## [,1] [,2] [,3] ## [1,] 0 3 6 ## [2,] 1 4 7 ## [3,] 2 5 8 Subtracting 1 to data1 subtract each value in the matrix by 1 Matrix Multiplication(scalar) data4 = data1*5 data4 ## [,1] [,2] [,3] ## [1,] 5 20 35 ## [2,] 10 25 40 ## [3,] 15 30 45 Matrix division data5 = data1/2 data5 ## [,1] [,2] [,3] ## [1,] 0.5 2.0 3.5 ## [2,] 1.0 2.5 4.0 ## [3,] 1.5 3.0 4.5 3.2.3 Data frame is a two dimensional data structure, like a 2d array/matrix with rows and columns. Lets convert a matrix into a dataframe vector1 = c(1:12) matrix1 = matrix(vector1, ncol=4) #create a matrix from the vector # Adding a column student Students=c(&quot;Pragya&quot;, &quot;Deepika&quot;, &quot;Chandran&quot;) data = data.frame(Students, matrix1) data ## Students X1 X2 X3 X4 ## 1 Pragya 1 4 7 10 ## 2 Deepika 2 5 8 11 ## 3 Chandran 3 6 9 12 The above data shows scores of different students in different subjects. The column names are automatically generated by R, however, the column names can be added as below. headers=c(&quot;Students&quot;, &quot;Geonomics&quot;, &quot;Proteomics&quot;, &quot;Microbiology&quot;, &quot;Biostatistics&quot;) colnames(data)=headers #add column names data ## Students Geonomics Proteomics Microbiology Biostatistics ## 1 Pragya 1 4 7 10 ## 2 Deepika 2 5 8 11 ## 3 Chandran 3 6 9 12 A rowwise addition can be performed on a data frame to find the total scores for each student in the four units ## Add a new column with total marks obtained data$total_marks=rowSums(data[, c(2, 3, 4, 5)]) #add from second to fifth column data ## Students Geonomics Proteomics Microbiology Biostatistics total_marks ## 1 Pragya 1 4 7 10 22 ## 2 Deepika 2 5 8 11 26 ## 3 Chandran 3 6 9 12 30 Find the average score for each student. data$average_marks=rowMeans(data[, c(2, 3, 4, 5)]) data ## Students Geonomics Proteomics Microbiology Biostatistics total_marks ## 1 Pragya 1 4 7 10 22 ## 2 Deepika 2 5 8 11 26 ## 3 Chandran 3 6 9 12 30 ## average_marks ## 1 5.5 ## 2 6.5 ## 3 7.5 "],["loops.html", "Chapter 4 Loops 4.1 For loops 4.2 While loop", " Chapter 4 Loops A loop is a sequence of instructions that are executed iterative until a condition is met. They are two types of loops in R, they are; - for loops - while loops 4.1 For loops This is a type of a loop that iterate over a sequence of elements, such as a vector, list, or sequence of numbers, executing a block of code for each element in the sequence. The loop iterates over each element of the sequence, one at a time, and executes the specified code block for each iteration. Here is the syntax of a for loop for (variable in sequence) { # Code block to be executed for each iteration } When a condition is met the execution/iteration stops Below is an example of R loop over a range of numbers 1 to 10 for (n in 1:10) { print(n*5) } ## [1] 5 ## [1] 10 ## [1] 15 ## [1] 20 ## [1] 25 ## [1] 30 ## [1] 35 ## [1] 40 ## [1] 45 ## [1] 50 The loop can also iterate over a vector and perform the preset condition. For instance in the code below, the loops through a vector and prints a square of each element in the vector. num=c(1,2,3,8,10) for (n in 1:length(num)) { print(num[n]^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 64 ## [1] 100 Breaking of a loop - a program stops once something happens for instance the below loops executes by incrementing n and breaks when n is greater than 7 #Stop the loop if the n is greater than 7 for (n in num) { if (n &gt; 7){ break } print(n) } ## [1] 1 ## [1] 2 ## [1] 3 4.2 While loop A while loop is a control flow statement in programming that repeatedly executes a block of code as long as a specified condition is true. The loop continues to execute until the condition becomes false. The below program executes as long as n is less than or equal to m. m=4 n=-9 while(n&lt;=m) { print(n) n=n+1 } ## [1] -9 ## [1] -8 ## [1] -7 ## [1] -6 ## [1] -5 ## [1] -4 ## [1] -3 ## [1] -2 ## [1] -1 ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 "],["working-with-files.html", "Chapter 5 Working with files 5.1 Reading a file from a dataframe 5.2 Write a new table to a file locally", " Chapter 5 Working with files 5.1 Reading a file from a dataframe This chapter explains how to read a file to a data frame using the readxl library. The readxl package can be installed from the console by install.packages(\"readxl\") command. Lets begin by importing the library # Import the library library(readxl) The readxl library can read .xlsx, xls files to a data frame. For this case, Human genome excel file is read. hg = read_excel(&quot;data/Human_genome.xlsx&quot;) View the data View(hg) In R, head() and tail() are functions used to view the first few rows or the last few rows of a data frame respectively. These functions are particularly useful for quickly inspecting the structure and content of a dataset. Here’s how you can use them for this case; head(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The head() function displays the first few rows of a data frame or a vector. By default, it shows the first 6 rows, but you can specify the number of rows to display using the n argument. head(hg, n=10) ## # A tibble: 10 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The tail argument can be used as; tail(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; to show the last 6 records while specifying n value will show the specified number of rows. R identifies this type of data as table or data frame. class(hg) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str() is used to find the nature of data such as column data types, number of rows and columns, column names , and first records in the dataframe str(hg) ## tibble [25 × 8] (S3: tbl_df/tbl/data.frame) ## $ Chromosome : chr [1:25] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Base_Pairs : num [1:25] 2.49e+08 2.42e+08 1.98e+08 1.90e+08 1.82e+08 ... ## $ Protein_Coding_genes : num [1:25] 2058 1309 1078 752 876 ... ## $ Pseudogenes : num [1:25] 1220 1023 763 727 721 ... ## $ Total_long_non_coding_RNA: num [1:25] 1200 1037 711 657 844 ... ## $ Total_small_nc_RA : num [1:25] 496 375 298 228 235 234 208 214 190 204 ... ## $ miRNA : num [1:25] 134 115 99 92 83 81 90 80 69 64 ... ## $ rRNA : num [1:25] 66 40 29 24 25 26 24 28 19 32 ... is.na() is used to check if there is null/blank values in the dataset. If there is it returns TRUE in place of the null point while it return FALSE in place of the value. sum(is.na(hg)) ## [1] 0 The “hg” data frame has no null values. Lets dive into biology to solve some of the questions about genetics Q1. Calculate the gene densityfor each chromosome The gene density is calculated in terms of genes per megabase base_Mb = hg$Base_Pairs/1000000 base_Mb ## [1] 248.956422 242.193529 198.295559 190.214555 181.538259 170.805979 ## [7] 159.345973 145.138636 138.394717 133.797422 135.086622 133.275309 ## [13] 114.364328 107.043718 101.991189 90.338345 83.257441 80.373285 ## [19] 58.617616 64.444167 46.709983 50.818468 156.040895 57.227415 ## [25] 0.016569 To make the values more clear, the results can be rounded off to two decimal place. rbase_Mb=round(base_Mb, digits = 2) rbase_Mb ## [1] 248.96 242.19 198.30 190.21 181.54 170.81 159.35 145.14 138.39 133.80 ## [11] 135.09 133.28 114.36 107.04 101.99 90.34 83.26 80.37 58.62 64.44 ## [21] 46.71 50.82 156.04 57.23 0.02 Q2. Calculate number of genes per megabase per chromosomes The protein coding genes are divided to the gene density. genes_per_megabase = round(hg$Protein_Coding_genes/base_Mb, digits = 2) genes_per_megabase ## [1] 8.27 5.40 5.44 3.95 4.83 6.14 6.21 4.66 5.68 5.48 ## [11] 9.61 7.76 2.86 7.75 6.01 9.66 14.38 3.36 25.11 8.44 ## [21] 5.01 9.60 5.40 1.24 784.60 Lets create a new column to the dataframe to the dataset hg[&quot;genes_per_Mb&quot;]=genes_per_megabase str(hg) ## tibble [25 × 9] (S3: tbl_df/tbl/data.frame) ## $ Chromosome : chr [1:25] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Base_Pairs : num [1:25] 2.49e+08 2.42e+08 1.98e+08 1.90e+08 1.82e+08 ... ## $ Protein_Coding_genes : num [1:25] 2058 1309 1078 752 876 ... ## $ Pseudogenes : num [1:25] 1220 1023 763 727 721 ... ## $ Total_long_non_coding_RNA: num [1:25] 1200 1037 711 657 844 ... ## $ Total_small_nc_RA : num [1:25] 496 375 298 228 235 234 208 214 190 204 ... ## $ miRNA : num [1:25] 134 115 99 92 83 81 90 80 69 64 ... ## $ rRNA : num [1:25] 66 40 29 24 25 26 24 28 19 32 ... ## $ genes_per_Mb : num [1:25] 8.27 5.4 5.44 3.95 4.83 6.14 6.21 4.66 5.68 5.48 ... 5.2 Write a new table to a file locally The write.table() function is used to write table to file on a local machine. The file is saved by deault to the working directory unless the path is specified. write.table(hg, file=&quot;data/hg_modified&quot;, quote=FALSE, sep=&#39;\\t&#39;, row.names=FALSE, col.names=TRUE) This file will be saved by default on the working directory unless the file path is changed. Checking if the new file is saved. file.show(&quot;data/hg_modified&quot;) &lt;— Come back later —&gt; "],["dpyr-library.html", "Chapter 6 Dpyr library 6.1 Application of Dplyr on Microbiology", " Chapter 6 Dpyr library readxl library has been used to read excel table into R and manipulate the data using R basic functions, now dplyr library will be used. This, dplyr library is an advanced package that has functions used to manipulate data. The functions are referred to as dplyr verbs. This are some opf the examples of dplyr verbs; - select - filter - arrange - mutate - group by - summarise &lt;–EXPLAIN THE PROCESS OF dplyr INSTALLATION USING RSTUDIO –&gt; #uncomment the below line to install dplyr #install.packages(&quot;dplyr&quot;) Load the required libraries library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(readxl) Before working on the data, the readxl package will be used to read the excel table. Then manipulate the data withndplyr. hg = read_excel(&quot;data/Human_genome.xlsx&quot;) tail(hg) #display the last 6 records of the data ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Apart from data retrieved from excel tables, there are some inbuilt freeely available datasets in R that a student can use for practice. data() function can be used to view some of the freely available datasets in R. data() or ls(&quot;package:datasets&quot;) ## [1] &quot;ability.cov&quot; &quot;airmiles&quot; &quot;AirPassengers&quot; ## [4] &quot;airquality&quot; &quot;anscombe&quot; &quot;attenu&quot; ## [7] &quot;attitude&quot; &quot;austres&quot; &quot;beaver1&quot; ## [10] &quot;beaver2&quot; &quot;BJsales&quot; &quot;BJsales.lead&quot; ## [13] &quot;BOD&quot; &quot;cars&quot; &quot;ChickWeight&quot; ## [16] &quot;chickwts&quot; &quot;co2&quot; &quot;CO2&quot; ## [19] &quot;crimtab&quot; &quot;discoveries&quot; &quot;DNase&quot; ## [22] &quot;esoph&quot; &quot;euro&quot; &quot;euro.cross&quot; ## [25] &quot;eurodist&quot; &quot;EuStockMarkets&quot; &quot;faithful&quot; ## [28] &quot;fdeaths&quot; &quot;Formaldehyde&quot; &quot;freeny&quot; ## [31] &quot;freeny.x&quot; &quot;freeny.y&quot; &quot;HairEyeColor&quot; ## [34] &quot;Harman23.cor&quot; &quot;Harman74.cor&quot; &quot;Indometh&quot; ## [37] &quot;infert&quot; &quot;InsectSprays&quot; &quot;iris&quot; ## [40] &quot;iris3&quot; &quot;islands&quot; &quot;JohnsonJohnson&quot; ## [43] &quot;LakeHuron&quot; &quot;ldeaths&quot; &quot;lh&quot; ## [46] &quot;LifeCycleSavings&quot; &quot;Loblolly&quot; &quot;longley&quot; ## [49] &quot;lynx&quot; &quot;mdeaths&quot; &quot;morley&quot; ## [52] &quot;mtcars&quot; &quot;nhtemp&quot; &quot;Nile&quot; ## [55] &quot;nottem&quot; &quot;npk&quot; &quot;occupationalStatus&quot; ## [58] &quot;Orange&quot; &quot;OrchardSprays&quot; &quot;PlantGrowth&quot; ## [61] &quot;precip&quot; &quot;presidents&quot; &quot;pressure&quot; ## [64] &quot;Puromycin&quot; &quot;quakes&quot; &quot;randu&quot; ## [67] &quot;rivers&quot; &quot;rock&quot; &quot;Seatbelts&quot; ## [70] &quot;sleep&quot; &quot;stack.loss&quot; &quot;stack.x&quot; ## [73] &quot;stackloss&quot; &quot;state.abb&quot; &quot;state.area&quot; ## [76] &quot;state.center&quot; &quot;state.division&quot; &quot;state.name&quot; ## [79] &quot;state.region&quot; &quot;state.x77&quot; &quot;sunspot.month&quot; ## [82] &quot;sunspot.year&quot; &quot;sunspots&quot; &quot;swiss&quot; ## [85] &quot;Theoph&quot; &quot;Titanic&quot; &quot;ToothGrowth&quot; ## [88] &quot;treering&quot; &quot;trees&quot; &quot;UCBAdmissions&quot; ## [91] &quot;UKDriverDeaths&quot; &quot;UKgas&quot; &quot;USAccDeaths&quot; ## [94] &quot;USArrests&quot; &quot;UScitiesD&quot; &quot;USJudgeRatings&quot; ## [97] &quot;USPersonalExpenditure&quot; &quot;uspop&quot; &quot;VADeaths&quot; ## [100] &quot;volcano&quot; &quot;warpbreaks&quot; &quot;women&quot; ## [103] &quot;WorldPhones&quot; &quot;WWWusage&quot; The above datasets are available in base R however some of the packages come with the newly installed packages. The data from all the packages can be viewd by data(package=.packages(all.available = TRUE)) A good example is the famous iris dataset that will be used in this course. The data will be invoked to R before assessment and wrangling. data(&quot;iris&quot;) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Calculating the summary statistics summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Lets write this dataset locally to a file. write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) or to remove quotes next to values write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE, quote = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) or to remove quotes and row names &lt;– remember to add screenshots–&gt; write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE, quote=FALSE, row.names = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) Chaining Chaining is the process of combining several operations together using the %&gt;% or forward pipe operator. The chained workflow succeeds each other until the whole process is done. 6.1 Application of Dplyr on Microbiology Genetics composition of an organism can be analyzed using dplyr, in this course unit it will be used to analyze the human genetics data. Read the dataset from a file into a dataframe hg = read_excel(&quot;data/Human_genome.xlsx&quot;) class(hg) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; review the first six records of the dataset head(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; the last six records of the dataset tail(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; sample_n() command is used to randomly sample fixed number of rows from the data frame. Lets sample five rows randomly hg %&gt;% sample_n(5) ## # A tibble: 5 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 46709983 234 185 305 ## 2 mtDNA 16569 13 0 0 ## 3 6 170805979 1048 801 639 ## 4 18 80373285 270 247 453 ## 5 Y 57227415 71 388 71 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; sample_fra() command can also be used to extract a percent of rows randomly. Lets samople 25% of the rows hg %&gt;% sample_frac(0.25, replace = FALSE) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 198295559 1078 763 711 ## 2 5 181538259 876 721 844 ## 3 21 46709983 234 185 305 ## 4 14 107043718 830 523 533 ## 5 17 83257441 1197 531 834 ## 6 8 145138636 677 613 735 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The replace argument allows repetition of rows when sampling when set TRUE and vice versa. The essence of dplyr in microbiology data can be explained better by questions. Q1. Which chromosomes has maximum size The functions used here are; select, arrange, slice The required columns will be selected i.e Chromosomes and Base_Pairs(size) The data will ordered according to Base_Pairs in descending order by the arrange command. the data will be “sliced” to select the first row All these processes will be chained to run progressively from process 1 to 3. All the above steps should be piped hg1 = hg %&gt;% #transfer the data to a new variable select(Chromosome, Base_Pairs) %&gt;% # select the required columns arrange(desc(Base_Pairs)) %&gt;% #order in descending order slice(1) hg1 ## # A tibble: 1 × 2 ## Chromosome Base_Pairs ## &lt;chr&gt; &lt;dbl&gt; ## 1 1 248956422 Q2. List of Chromosomes with more than 500 pseudogenes and more than 1000 protein coding genes The human genome data frame will be filtered to find the Chromosomes with more than 500 pseudogenes and more than 1000 protein coding genes. &amp; condition is used in the filter hg2=hg%&gt;% filter(Pseudogenes&gt;500 &amp; Protein_Coding_genes&gt;1000) hg2 ## # A tibble: 8 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 6 170805979 1048 801 639 ## 5 11 135086622 1298 821 710 ## 6 12 133275309 1034 617 848 ## 7 17 83257441 1197 531 834 ## 8 19 58617616 1472 512 628 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Q3. List of Chromosomes with more tha 500 pseudogenes or more than 1000 protein coding genes and miRNA more than 100 a frame will be filtered to find the Chromosomes with more than 500 pseudogenes The human genome dator more than 1000 protein coding genes and mtRNA more than 100. The &amp; and | conditions will be used in place of “and” and “or” respectively. hg2=hg %&gt;% filter((Pseudogenes&gt;500|Protein_Coding_genes&gt;1000) &amp; miRNA&gt;100) hg2 ## # A tibble: 4 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 19 58617616 1472 512 628 ## 4 X 156040895 842 874 271 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Q4. Which 10 Chromosomes have the highest protein gene density (Genes per megabase) Mutate -&gt; is a command to create a new column Lets create a column of genes per megabase where a megabase is 1000000 base pairs hg3=hg %&gt;% mutate(Genes_per_Mb=round((Protein_Coding_genes/(Base_Pairs/100000)), digit=2)) hg3 ## # A tibble: 25 × 9 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ 15 more rows ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 4 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt;, ## # Genes_per_Mb &lt;dbl&gt; then order the data according to genes per megabse column (Genes_per_mb) in descending order and select the first 10 rows using arrange and select commands. hg4=hg3 %&gt;% arrange(desc(Genes_per_Mb)) %&gt;% # order in descending order select(Chromosome, Genes_per_Mb) %&gt;% # select the required columns slice(1:10) # select the top 10 hg4 ## # A tibble: 10 × 2 ## Chromosome Genes_per_Mb ## &lt;chr&gt; &lt;dbl&gt; ## 1 mtDNA 78.5 ## 2 19 2.51 ## 3 17 1.44 ## 4 16 0.97 ## 5 11 0.96 ## 6 22 0.96 ## 7 20 0.84 ## 8 1 0.83 ## 9 12 0.78 ## 10 14 0.78 Q5. Calculate the mean of gene density for autosomes, sex chromosomes and mitochondrial genes autosomes=rep(&quot;A&quot;, 22) #create a vector with 22 As print(autosomes) ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [20] &quot;A&quot; &quot;A&quot; &quot;A&quot; chr_class=c(autosomes, &quot;S&quot;, &quot;S&quot;, &quot;M&quot;) chr_class ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [20] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;S&quot; &quot;S&quot; &quot;M&quot; hg5= hg3 %&gt;% mutate(Type=chr_class) hg5 # confirm the new column &quot;Type&quot; is added ## # A tibble: 25 × 10 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ 15 more rows ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 5 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt;, ## # Genes_per_Mb &lt;dbl&gt;, Type &lt;chr&gt; Group by chromosomes and calculate the mean density hg6=hg5 %&gt;% group_by(Type) %&gt;% summarise(gene_density=mean(Genes_per_Mb)) hg6 ## # A tibble: 3 × 2 ## Type gene_density ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 0.754 ## 2 M 78.5 ## 3 S 0.33 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
