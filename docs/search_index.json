[["r---introduction.html", "R Course Chapter 1 R - Introduction 1.1 R - Basic Concepts and applications 1.2 Why R? 1.3 R studio 1.4 Basic Mathematics like operators 1.5 R Markdown 1.6 Installation of packages", " R Course YOUR NAME HERE 2024-05-23 Chapter 1 R - Introduction 1.1 R - Basic Concepts and applications R (programming language) is a language and environment for statistical computing and graphics 1.2 Why R? Developed by Statisticians - R is Excellent for Statistical Computing and Analysis Open-source (Free) - R is an open-source programming language. Anyone can work with R without any license or fee. Due to this, R has a huge community that contributes to its environment. A Large Variety of Specialized Libraries - These libraries support and enhance the R development environment. R Studio - A graphic user interface to R - easier to grasp and learn. Cross-platform Support - R is machine-independent. It supports the cross-platform operation. Thus, it is usable on many different operating systems. Can do Data Cleansing, Data Wrangling, and Web Scraping - R can collect data from the internet through web scraping and other means. It can also perform data cleansing. R is also useful for data wrangling which is the process of converting raw data into the desired format for easier consumption. Powerful Graphics - R has extensive libraries that can produce production quality graphs and visualizations. Compatible with other Programming Languages - R is compatible with other languages like C, C++, and FORTRAN. Other languages like .NET, Java, Python can also directly manipulate objects. Compatible with high performance computing and Big Data Analytics. 1.3 R studio Rstudio is an integrated development environment(IDE) for R. It includes a console, syntax-highlighting editor that supports direct code execution as well as tools for plotting history, debugging and work space management. R studio is an open source software from posit and can be freely be downloaded from https://posit.co/download/rstudio-desktop/. This link has all the installation files for Mac, Linux and Windows. You will download the installation file and install based on your computer operating system. 1.3.1 RStudio - Look and Feel The image above is for R code in R Studio. Each quadrant has its own function. text editor serves as the primary interface for writing and editing R scripts, Markdown documents, and other text-based files stand input/output (console/terminal/jobs) It is the bottom left quadrant in R Studio that serves as a command-line interface where you can directly interact with R such as code execution and output display. all data and its properties quadrants It is the top right quadrant in Rstudio that is typically the “Environment” pane, which provides information and tools for managing your R environment such as data importation, display of variables. plots and file directory structure The bottom right quadrant in RStudio typically houses the “Files”, “Plots”, “Packages”, “Help”, and “Viewer” tabs. 1.4 Basic Mathematics like operators 1.4.1 Basics To do simple mathematical operations, the following operators are used; + for addition - for subtraction / for division * for multiplication The following examples will illustrates how to do simple arithmetic in R. Example 1 2+3 # addition ## [1] 5 Example 2 2398 + 4653 #addition ## [1] 7051 Example 3 6-2 #subtraction ## [1] 4 Example 4 30-15# subtraction ## [1] 15 Example 5 10 * 3 #multiplication ## [1] 30 Example 6 30/15 # division ## [1] 2 Variables can be used instead of hard coded values like m = 15 n = 30 answer = m - n answer ## [1] -15 or m = -5 n = 20 answer = m + n answer ## [1] 15 1.4.2 BODMAS rule If there is are multiple different operators in a single expression then the BODMAS(Brackets, Orders (i.e., powers and square roots, etc.), Division and Multiplication, Addition and Subtraction) rule will apply when solving. Basic BODMAS answer = 5 + 2 * (10 - 4) answer ## [1] 17 The above expression is solved as follows; evaluate the brackets: (10 - 4) which is 6, then, perform multiplication: 2 * 6 which is 12, finally, addition: 5 + 12 which is 17. Including Exponentiation answer = (6 + 4) ^ 2 - 3 * 5 answer ## [1] 85 The above equation is solved as follows; evaluate the brackets: (6 + 4) which is 10. then, perform exponentiation: 10 ^ 2 which is 100. then, perform multiplication: 3 * 5 which is 15. finally, subtraction: 100 - 15 which is 85. More Complex and Interesting BODMAS answer = (20 / 4) + 3^2 * (2 + 1) - 5 answer ## [1] 27 The above expression is solved as follows; evaluate the brackets: (20 / 4) which is 5 and (2 + 1) which is 3. perform exponentiation: 3^2 which is 9. perform multiplication: 9 * 3 which is 27. addition and subtraction in order: 5 + 27 which is 32, and 32 - 5 which is 27 NOTE: These operators are only applicable for numerical variables. 1.5 R Markdown R Markdown is a versatile markup language that allows you to create dynamic documents that integrate text, code, and output. It is widely used in data analysis, scientific research, and reporting The figure shows how markdown looks like Each chunk can be run separately in a single file, also the variable in one chunk can be reused by the next/later chunks Anything added outside the chuck will not be executed in the program The R markdown can be knitted to a html, pdf, or word file and presented to the audience 1.6 Installation of packages R libraries/packages can be installed by invoking install.packages(\"package_name\") to the console. The figure below shows how to install expn library. Alternatively, a package can be installed from the graphical user interface in R by clicking ‘tools’ tab then “install.packages”. A dialogue box will appear requesting you to enter the name of the package to be installed. Thereafter, click the ‘install’ button on the dialogue box to install the package. "],["data-types-and-data-structures.html", "Chapter 2 Data Types and Data Structures 2.1 Data types 2.2 Data Structures", " Chapter 2 Data Types and Data Structures 2.1 Data types There are different kinds of values in R that can be manipulated in variables in R. class()function is used to check the data type of a value or a variable. Different data types include; Numeric These represent numeric values such as integers and decimals. They are used for mathematical expressions and quantitative data analysis. Example: a=23.5 class(a) #check the data type of a ## [1] &quot;numeric&quot; a whole number without without a decimal is also numeric for instance 45, 8, 0 and 73. class(45) ## [1] &quot;numeric&quot; class(8) ## [1] &quot;numeric&quot; class(0) ## [1] &quot;numeric&quot; class(73) ## [1] &quot;numeric&quot; Integers They represent whole numbers without any any decimals and are a subclass of numeric. L is added at the end of a whole number to indicate that it is an integer. a=23L #add L to show it is an integer class(a) ## [1] &quot;integer&quot; Lets store age as an integer. Note the ‘L’ after the number 27 age = 27L class(age) ## [1] &quot;integer&quot; Characters They represent text strings such as names, sentences and labels. They are enclosed in ” or ’. a=&quot;DNA&quot; class(a) ## [1] &quot;character&quot; Lets use name as a character name = &quot;Pragya&quot; class(name) ## [1] &quot;character&quot; for an object item = &quot;car&quot; # &quot;car&quot; is stored in a variable item class(item) ## [1] &quot;character&quot; Character data types can have empty spaces in between, for instance; fullname = &quot;Salman Khan&quot; class(fullname) ## [1] &quot;character&quot; Logical They represent boolean values which has only distinct value; TRUE or FALSE. a=TRUE #logical data types is either TRUE or FALSE only class(a) ## [1] &quot;logical&quot; changing it to FALSE b = FALSE class(b) ## [1] &quot;logical&quot; Complex They represent complex numbers with real and imaginary parts a=2+3i # Complex data types have &#39;i&#39; at the end of each number class(a) ## [1] &quot;complex&quot; 2 is the real part while 3i is the imaginary part. Also, complex numbers can be created by complex() function with real and imaginary as the arguments. z = complex(real = 3, imaginary = 7) print(z) #show the comlex value ## [1] 3+7i class(z) #confirm that it is a complex number ## [1] &quot;complex&quot; Lets try another values to fit to the complex data type 2+5i z = complex(real=2, imaginary = 5) print(z) ## [1] 2+5i class(z) ## [1] &quot;complex&quot; 7 + 6i m=complex(real=7, imaginary = 6) print(m) ## [1] 7+6i class(m) ## [1] &quot;complex&quot; 4i - 1 b = 4i-1 print(b) ## [1] -1+4i class(b) ## [1] &quot;complex&quot; Complex data types can include the imaginary part only without real number, R will assume the real part to be 0(zero). For instance; h = 3i print(h) ## [1] 0+3i class(h) ## [1] &quot;complex&quot; Raw They represent a vector of bytes in their natural form. They are used in storing binary data. Example; a=charToRaw(&quot;DNA&quot;) print(a) ## [1] 44 4e 41 class(a) ## [1] &quot;raw&quot; # convert back to character b=rawToChar(a) class(b) ## [1] &quot;character&quot; “Hello world” can be represented as in the results below when converted to raw data type binary_data = charToRaw(&quot;Hello World&quot;) print(binary_data) ## [1] 48 65 6c 6c 6f 20 57 6f 72 6c 64 class(binary_data) ## [1] &quot;raw&quot; Numeric can also be represented as raw vectors; age=as.raw(27) print(age) ## [1] 1b class(age) ## [1] &quot;raw&quot; 2.2 Data Structures This is the organization of data into one or multiple data values in specific structures. Different types of data structures in R include; Vector Matrix Data frame 2.2.1 Vector A vector is a single entity consisting of a collection of things. They are versatile providing a basis of many operations in statistics and data manipulation hence it is important to have knowledge of vectors for effective programming in R. Vectors are created using a c() function, here is an example of a vector. marks = c(23, 67, 98, 34, 98, 21) print(marks) ## [1] 23 67 98 34 98 21 The class function is utilized to determine the data types present within vector data values. class(marks) ## [1] &quot;numeric&quot; The vector “marks” consist of only numeric values is.vector function is used to check if the variable is a vector. It will return a Boolean value, TRUE if the variable in question is truly a vector while FALSE if otherwise. is.vector(marks) ## [1] TRUE unlike matrix and data frame, vector has no dimension dim(marks) ## NULL length() function is used to count number of elements in vectors. In our case vector marks, marks = c(23, 67, 98, 34, 98, 21) has six elements, therefore, length() command will return 6. length(marks) ## [1] 6 Index is the position of an element in a vector, in R it starts at index 1 - lets say we find the third element by index 3 marks[3] ## [1] 98 value “98” is at index 3, or the third in the vector. The first value/element of a vector is indexed 1, for instance if we find the first value in the vector marks. marks[1] #returns the first value ## [1] 23 The sequence goes on, the second, third, fourth, fifth … values are indexed as , 2, 3, 4, 5… respectively. i.e the n^th value is indexed as n. Vectors can also be sliced to obtain values over a range of indices. For instance the code below shows how to retrieve the from the second to the fourth values as a vector print(marks[2:4]) ## [1] 67 98 34 is.vector(marks[2:4]) # confirm if the retrieved values are in a vector ## [1] TRUE An element at a specific index in a vector can be excluded by adding a - sign before the index value. marks[-2] #exclude the element at index 2 ## [1] 23 98 34 98 21 rev() command is used to reverse the order of elements in a vector rev(marks) ## [1] 21 98 34 98 67 23 2.2.1.1 Mathematical Operations in a vector The summary/descriptive statistics are calculated by summary() command. summary(marks) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 21.00 25.75 50.50 56.83 90.25 98.00 sum(), median(), and mean() are used to calculate the total, median, average and the standard deviation of the values in a vector print(&quot;MARKS&quot;) ## [1] &quot;MARKS&quot; print(paste(&quot;TOTAL: &quot;, sum(marks))) ## [1] &quot;TOTAL: 341&quot; print(paste(&quot;MEDIAN: &quot;, median(marks))) ## [1] &quot;MEDIAN: 50.5&quot; print(paste(&quot;AVERAGE: &quot;, mean(marks))) ## [1] &quot;AVERAGE: 56.8333333333333&quot; Vector multiplication and division - vectors can be multiplied or divided by a scalar value of another vector of the same length and numeric data type. For instance, the vector marks=c(23, 67, 98, 34, 98, 21) is being multiplied by a scalar value 2, that will multiply each element in a vector by two. double_marks =2 * marks marks ## [1] 23 67 98 34 98 21 double_marks ## [1] 46 134 196 68 196 42 The values in the vector marks can also be scaled down to a half when multiplied by a scalar value 0.5. half_marks =0.5 * marks marks ## [1] 23 67 98 34 98 21 half_marks ## [1] 11.5 33.5 49.0 17.0 49.0 10.5 Alternatively, instead of multiplying the vector by 0.5, it can be divided by 2 a scalar value two. This is what is referred to as vector division. half_marks = marks/2 half_marks ## [1] 11.5 33.5 49.0 17.0 49.0 10.5 Two or more vectors of numeric values of the equal length can be multiplied or divided by each other. The example below demonstrates vector by vector multiplication. Each value is multiplied by a value of a corresponding index in the next vector such that; 3 is multiplied by 7 to be 21 5 is multiplied by 3 to be 15 1 is multiplied by 9 to be 9. The resultant vector is now 21 15 9. a = c(3, 5, 1) b = c(7, 3, 9) ab = a*b ab ## [1] 21 15 9 ba = b*a # is the same as ab ba ## [1] 21 15 9 The same vectors can also be divided by each other provided they are of the same length and all have numeric values. The order of vector division, for instance in the first case vector a is divided by vector b such that; 3 is divided by 7 to be 0.4285714 5 is divided by 3 to be 1.6666667 1 is divided by 9 to be 0.1111111. The resultant vector is now 0.4285714 1.6666667 0.1111111. # First case a = c(3, 5, 1) b = c(7, 3, 9) # Divide vector a by b abdiv=a/b abdiv ## [1] 0.4285714 1.6666667 0.1111111 , and in the second case the order of vector division is reversed by vector b being divided by a such that; 7 is divided by 3 to be 2.333333 3 is divided by 5 to be 0.600000 9 is divided by 1 to be 9.000000. The resultant vector is now 2.333333 0.600000 9.000000. # Second case a = c(3, 5, 1) b = c(7, 3, 9) # Divide vector b by a badiv=b/a badiv ## [1] 2.333333 0.600000 9.000000 However, when multiplying vectors of unequal length the shorter one is replicated to match the longer vector. It will then return a warning. The case below shows how vector e=c(1,2,3,4,5) and f=c(1,2) are multiplied. vector f=c(1,2) will be replicated to match the length of vector e, therefore, vector f will be f=c(1,2,1,2,1). The process of vector by vector multiplication will be followed. e=c(1,2,3,4,5) f=c(1,2) ef = e*f #it shows an error ## Warning in e * f: longer object length is not a multiple of shorter object ## length ef #shows results since f is replicated to match e as f=c(1,2,1,2,1) ## [1] 1 4 3 8 5 Multiple vectors can be concatenated/combined to come up with one giant vector a ## [1] 3 5 1 b ## [1] 7 3 9 z=c(a,b,a) #concatenates the vectors z ## [1] 3 5 1 7 3 9 3 5 1 2.2.1.2 Character Vectors Vectors can also contain character data types for instance my_name = c(&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;Vipin&quot;) my_name[5] = &quot;Singh&quot; #insert at the end my_name ## [1] &quot;My&quot; &quot;name&quot; &quot;is&quot; &quot;Vipin&quot; &quot;Singh&quot; Combining the vectors to a single string. For instance the vector my_name = c(\"My\", \"name\", \"is\", \"Vipin\") is combined to \"My name is Vipin\". The collapse argument is used as below; print(paste(my_name, collapse=&quot; &quot;)) ## [1] &quot;My name is Vipin Singh&quot; Calculate the summary/descriptive statistics of the vector by function summary(). It finds; Count/length Class (data type) Mode summary(my_name) ## Length Class Mode ## 5 character character 2.2.1.3 Vectors with mixed data types A vector can also consist of characters values and numeric values for instance numbers=c(1,&quot;two&quot;, 3, &quot;three&quot;) numbers ## [1] &quot;1&quot; &quot;two&quot; &quot;3&quot; &quot;three&quot; however the numeric elements in the vector are recognized by R as character data type. They can be converted to numeric by; as.numeric(numbers[1]) + 2 ## [1] 3 the integers can be converted by; as.integer(numbers[1]) ## [1] 1 2.2.1.4 Named Vectors Variable names can be assigned to vectors like; named_vector=c(EcoR1=&quot;GAATTC&quot;, HindIII=&quot;AAGCTT&quot;, Pst1=&quot;CTGCAG&quot;) named_vector ## EcoR1 HindIII Pst1 ## &quot;GAATTC&quot; &quot;AAGCTT&quot; &quot;CTGCAG&quot; to access the names of the values is; names(named_vector) ## [1] &quot;EcoR1&quot; &quot;HindIII&quot; &quot;Pst1&quot; A vector element can be accessed using its name named_vector[&quot;EcoR1&quot;] # find the value of a vector by its name ## EcoR1 ## &quot;GAATTC&quot; 2.2.1.5 Generating number series as vectors The seq function in R is used to generate sequences of numbers. It takes several arguments, including from, to, by, and length.out, among others, to specify the range and increment of the sequence. Here’s a brief overview of its usage: from: The starting value of the sequence. to: The end value of the sequence. # Generate a sequence from 1 to 10 series = seq(from=1, to=20) series ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # It can also be written as series = seq(1,20) series ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class(series) ## [1] &quot;integer&quot; by: The increment between consecutive values in the sequence. # generate numbers 0 to 10 incremented by 0.5 series3=seq(0, 10, by=0.5) series3 ## [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 ## [16] 7.5 8.0 8.5 9.0 9.5 10.0 length: The desired length of the sequence. # generate 10 numbers from 0 to 6 series4=seq(0, 6, length=10) series4 ## [1] 0.0000000 0.6666667 1.3333333 2.0000000 2.6666667 3.3333333 4.0000000 ## [8] 4.6666667 5.3333333 6.0000000 seq(0, 6) ## [1] 0 1 2 3 4 5 6 along.with: An optional vector argument specifying the length and names of the output sequence. # Generate a sequence along with a vector seq(along.with = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] 1 2 3 2.2.1.6 Null data points in vectors NA data (Not available or blank) for instance marks=c(78,65, 98, 87, 89, NA) sum(is.na(marks)) #Count the null values in a vector ## [1] 1 Other inbuilt functions for mathematical operations cannot be done if Null values exists in a vector unless they are removed/ignored #sum(marks) #returns an error sum(marks, na.rm = TRUE) #remove null values before calculating the sum ## [1] 417 median(marks, na.rm = TRUE) ## [1] 87 summary(marks, na.rm = TRUE) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 65.0 78.0 87.0 83.4 89.0 98.0 1 2.2.2 Matrix A matrix is a two dimensional data type that contain a single class of data. The code below shows one can produce a matrix from a vector vector1 = seq(1, 9) # Convert to matrix ## create by column data1=matrix(vector1, ncol=3) data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 A vector of values 1 to 9 is being converted to a matrix where the values are being arranged column wise by default. A matrix has a multiple dimensions, the most common type of matrix is two dimesnional. dim(data1) ## [1] 3 3 is.matrix() function is used to confirm if a given variable is a matrix and it return a boolean value. is.matrix(data1) ## [1] TRUE A matrix can also be created row-wise from a vector. ## create by row data2=matrix(vector1, ncol=3, byrow=TRUE) data2 # is a transpose of data1 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Matrix is recognized either as a matrix or array by R class(data1) ## [1] &quot;matrix&quot; &quot;array&quot; To access a specific data point in a matrix, the matrix is indexed by row then column for instance matrix_data[row_index, column_index] data1[3, 2] ## [1] 6 To access a single row, in this case we find the second row which will be returned as a vector data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 row2 = data1[2,] # access row 2 is.vector(row2) #can be accessed by row 2 ## [1] TRUE To access a single column data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 col3=data1[,3] # access column 3 is.vector(col3) #can be accessed by column 3 ## [1] TRUE Count the number of rows in a matrix nrow(data1) ## [1] 3 data1 has 3 rows Count the number of columns in a matrix ncol(data1) ## [1] 3 2.2.2.1 Mathematical Operations in a matrix Matrix Addition Matrix addition can be done by adding a number to the matrix or another matrix of the equal number of rows and columns. data1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 data2 = data1 + 3 data2 ## [,1] [,2] [,3] ## [1,] 4 7 10 ## [2,] 5 8 11 ## [3,] 6 9 12 For instance, the code snippet above demonstrates matrix addition by a numeric value. Adding value 3 to a matrix adds each value in the matrix by 3. To demonstrate a matrix to a matrix addition, we will create two matrices of the equal dimensions then add to each other. data1 = matrix(seq(1, 9), ncol=3, byrow=TRUE) print(data1) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 data2 = matrix(seq(1, 18, 2), ncol=3, byrow=TRUE) print(data2) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 7 9 11 ## [3,] 13 15 17 # Add data1 to data2 resultant_matrix = data1 + data2 resultant_matrix ## [,1] [,2] [,3] ## [1,] 2 5 8 ## [2,] 11 14 17 ## [3,] 20 23 26 Matrix Subtraction The same concept of matrix addition applies to matrix subtraction as well. data3 = data1-1 #reduce each value by 1 data3 ## [,1] [,2] [,3] ## [1,] 0 1 2 ## [2,] 3 4 5 ## [3,] 6 7 8 Subtracting 1 to data1 subtract each value in the matrix by 1. Lets now subtract data1 from data2. data1 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 data2 ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 7 9 11 ## [3,] 13 15 17 resultant_matrix = data2-data1 resultant_matrix ## [,1] [,2] [,3] ## [1,] 0 1 2 ## [2,] 3 4 5 ## [3,] 6 7 8 Matrix Multiplication(scalar) A matrix can be multiplied by a scalar whereby the scalar value multiplies all the cells in the matrix. data4 = data1*5 data4 ## [,1] [,2] [,3] ## [1,] 5 10 15 ## [2,] 20 25 30 ## [3,] 35 40 45 Matrix multiplication applies a concept of row by column. The row of the first matrix is multiplied with a row of the second matrix. It also known as the dot product. data1 ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 data2 ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 7 9 11 ## [3,] 13 15 17 product_matrix = data1 * data2 product_matrix ## [,1] [,2] [,3] ## [1,] 1 6 15 ## [2,] 28 45 66 ## [3,] 91 120 153 Matrix division data5 = data1/2 data5 ## [,1] [,2] [,3] ## [1,] 0.5 1.0 1.5 ## [2,] 2.0 2.5 3.0 ## [3,] 3.5 4.0 4.5 2.2.3 Data frame is a two dimensional data structure, like a 2d array/matrix with rows and columns. Lets convert a matrix into a data frame vector1 = c(1:12) matrix1 = matrix(vector1, ncol=4) #create a matrix from the vector # Adding a column student Students=c(&quot;Pragya&quot;, &quot;Deepika&quot;, &quot;Chandran&quot;) data = data.frame(Students, matrix1) data ## Students X1 X2 X3 X4 ## 1 Pragya 1 4 7 10 ## 2 Deepika 2 5 8 11 ## 3 Chandran 3 6 9 12 The above data shows scores of different students in different subjects. The column names are automatically generated by R, however, the column names can be added as below. headers=c(&quot;Students&quot;, &quot;Geonomics&quot;, &quot;Proteomics&quot;, &quot;Microbiology&quot;, &quot;Biostatistics&quot;) colnames(data)=headers #add column names data ## Students Geonomics Proteomics Microbiology Biostatistics ## 1 Pragya 1 4 7 10 ## 2 Deepika 2 5 8 11 ## 3 Chandran 3 6 9 12 A row wise addition can be performed on a data frame to find the total scores for each student in the four units ## Add a new column with total marks obtained data$total_marks=rowSums(data[, c(2, 3, 4, 5)]) #add from second to fifth column data ## Students Geonomics Proteomics Microbiology Biostatistics total_marks ## 1 Pragya 1 4 7 10 22 ## 2 Deepika 2 5 8 11 26 ## 3 Chandran 3 6 9 12 30 Find the average score for each student.rowMeans() is used the average of each row/record. data$average_marks=rowMeans(data[, c(2, 3, 4, 5)]) data ## Students Geonomics Proteomics Microbiology Biostatistics total_marks ## 1 Pragya 1 4 7 10 22 ## 2 Deepika 2 5 8 11 26 ## 3 Chandran 3 6 9 12 30 ## average_marks ## 1 5.5 ## 2 6.5 ## 3 7.5 "],["loops.html", "Chapter 3 Loops 3.1 For loops 3.2 While loop", " Chapter 3 Loops A loop is a sequence of instructions that are executed iterative until a condition is met. They are two types of loops in R, they are; - for loops - while loops 3.1 For loops This is a type of a loop that iterate over a sequence of elements, such as a vector, list, or sequence of numbers, executing a block of code for each element in the sequence. The loop iterates over each element of the sequence, one at a time, and executes the specified code block for each iteration. Here is the syntax of a for loop for (variable in sequence) { # Code block to be executed for each iteration } When a condition is met the execution/iteration stops Below is an example of R loop over a range of numbers 1 to 10 for (n in 1:10) { print(n*5) } ## [1] 5 ## [1] 10 ## [1] 15 ## [1] 20 ## [1] 25 ## [1] 30 ## [1] 35 ## [1] 40 ## [1] 45 ## [1] 50 Not only can for loops go through a set of numeric values but also they can loop through a vector of characters. For instance; # This will loop through a set of fruits fruits &lt;- c(&quot;apples&quot;, &quot;bananas&quot;, &quot;oranges&quot;) for (fruit in fruits) { print(paste(&quot;I like&quot;, fruit)) } ## [1] &quot;I like apples&quot; ## [1] &quot;I like bananas&quot; ## [1] &quot;I like oranges&quot; A for loop can run within another for loop, this is referred to as a “Nested for loop”. The code below shows how nested for loops work for (i in 1:3) { for (j in 1:2) { print(paste(&quot;i:&quot;, i, &quot;, j:&quot;, j)) } } ## [1] &quot;i: 1 , j: 1&quot; ## [1] &quot;i: 1 , j: 2&quot; ## [1] &quot;i: 2 , j: 1&quot; ## [1] &quot;i: 2 , j: 2&quot; ## [1] &quot;i: 3 , j: 1&quot; ## [1] &quot;i: 3 , j: 2&quot; These nested for loops are very useful when working with multidimensional data structures like matrices. Like matrix by matrix multiplication; Example 1 # Matrix multiplication matrix1 &lt;- matrix(1:4, nrow = 2) matrix1 ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 matrix2 &lt;- matrix(5:8, nrow = 2) matrix2 ## [,1] [,2] ## [1,] 5 7 ## [2,] 6 8 # Matrices are multiplied row(of matrix1) by column(of matrix2) result &lt;- matrix(0, nrow = nrow(matrix1), ncol = ncol(matrix2)) for (i in 1:nrow(matrix1)) { for (j in 1:ncol(matrix2)) { for (k in 1:ncol(matrix1)) { result[i, j] &lt;- result[i, j] + matrix1[i, k] * matrix2[k, j] } } } print(result) ## [,1] [,2] ## [1,] 23 31 ## [2,] 34 46 Example 2 # Define two matrices matrix1 &lt;- matrix(1:9, nrow = 3) matrix1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 matrix2 &lt;- matrix(9:1, nrow = 3) matrix2 ## [,1] [,2] [,3] ## [1,] 9 6 3 ## [2,] 8 5 2 ## [3,] 7 4 1 # Initialize result matrix result &lt;- matrix(0, nrow = nrow(matrix1), ncol = ncol(matrix2)) # Perform matrix multiplication using nested for loops for (i in 1:nrow(matrix1)) { for (j in 1:ncol(matrix2)) { for (k in 1:ncol(matrix1)) { result[i, j] &lt;- result[i, j] + matrix1[i, k] * matrix2[k, j] } } } result ## [,1] [,2] [,3] ## [1,] 90 54 18 ## [2,] 114 69 24 ## [3,] 138 84 30 The loop can also iterate over a vector and perform the preset condition. For instance in the code below, the loops through a vector and prints a square of each element in the vector. num=c(1,2,3,8,10) for (n in 1:length(num)) { print(num[n]^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 64 ## [1] 100 Breaking of a loop - a program stops once something happens for instance the below loops executes by incrementing n and breaks when n is greater than 7 #Stop the loop if the n is greater than 7 for (n in num) { if (n &gt; 7){ break } print(n) } ## [1] 1 ## [1] 2 ## [1] 3 3.2 While loop A while loop is a control flow statement in programming that repeatedly executes a block of code as long as a specified condition is true. After executing the code block, the program returns at the beginning the condition, if its is TRUE the code block is executed again. The loop continues to execute until the condition becomes false. while (condition) { # Code block to be executed } Example 1 The below program executes as long as n is less than or equal to m. m=4 n=-9 while(n&lt;=m) { print(n) n=n+1 } ## [1] -9 ## [1] -8 ## [1] -7 ## [1] -6 ## [1] -5 ## [1] -4 ## [1] -3 ## [1] -2 ## [1] -1 ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 The condition of the above code is that the program will executes as long as n is less than or equal to m. The value of n is incremented by 1 and printed out until as long its less than or equal to m. Example 2 i = 10 while (i &gt;= 5) { print(i) i = i - 1 } ## [1] 10 ## [1] 9 ## [1] 8 ## [1] 7 ## [1] 6 ## [1] 5 This while loop prints the values of i from 10 to 5. It starts with `i equal to 10 and continues iterating as long as i is more than or equal to 5. Inside the loop, each value of i is printed, and i is reduced by 1 in each iteration. Infinite Loop: If the condition in a while loop always evaluates to TRUE, the loop becomes an infinite loop, which continuously executes the code block without stopping. Infinite loops should be avoided, as they can cause the program to hang or become unresponsive. There are different use cases in R while loops. These are a few examples of use cases; Calculating factorial # Function to calculate factorial factorial = function(n) { result = 1 i = 1 while (i &lt;= n) { result = result * i i = i + 1 } return(result) } # Calculate factorial of 5 factorial_5 = factorial(5) print(factorial_5) # Output: 120 ## [1] 120 Use input validation # Prompt user to enter a number until a valid numeric value is provided num = NA while (is.na(num)) { input = 3 num = as.numeric(input) if (is.na(num)) { cat(&quot;Invalid input. Please enter a numeric value.\\n&quot;) } } print(paste(&quot;You entered:&quot;, num)) ## [1] &quot;You entered: 3&quot; Generating a fibonacci series # Generate Fibonacci series up to n terms fibonacci = function(n) { a = 0 b = 1 i = 1 while (i &lt;= n) { cat(a, &quot; &quot;) next_term = a + b a = b b = next_term i = i + 1 } cat(&quot;\\n&quot;) } # Generate Fibonacci series with 10 terms fibonacci(10) # Output: 0 1 1 2 3 5 8 13 21 34 ## 0 1 1 2 3 5 8 13 21 34 "],["working-with-files.html", "Chapter 4 Working with files 4.1 .XLSX, XLS files 4.2 .CSV files", " Chapter 4 Working with files 4.1 .XLSX, XLS files 4.1.1 Reading a file to a dataframe This chapter explains how to read a file to a data frame using the readxl library. The readxl package can be installed from the console by install.packages(\"readxl\") command. Lets begin by importing the library # Import the library library(readxl) The readxl library can read .xlsx, xls files to a data frame. For this case, Human genome excel file is read. hg = read_excel(&quot;data/Human_genome.xlsx&quot;) View the data set str(hg) ## tibble [25 × 8] (S3: tbl_df/tbl/data.frame) ## $ Chromosome : chr [1:25] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Base_Pairs : num [1:25] 2.49e+08 2.42e+08 1.98e+08 1.90e+08 1.82e+08 ... ## $ Protein_Coding_genes : num [1:25] 2058 1309 1078 752 876 ... ## $ Pseudogenes : num [1:25] 1220 1023 763 727 721 ... ## $ Total_long_non_coding_RNA: num [1:25] 1200 1037 711 657 844 ... ## $ Total_small_nc_RA : num [1:25] 496 375 298 228 235 234 208 214 190 204 ... ## $ miRNA : num [1:25] 134 115 99 92 83 81 90 80 69 64 ... ## $ rRNA : num [1:25] 66 40 29 24 25 26 24 28 19 32 ... In R, head() and tail() are functions used to view the first few rows or the last few rows of a data frame respectively. These functions are particularly useful for quickly inspecting the structure and content of a dataset. Here’s how you can use them for this case; head(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The head() function displays the first few rows of a data frame or a vector. By default, it shows the first 6 rows, but you can specify the number of rows to display using the n argument. head(hg, n=10) ## # A tibble: 10 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The tail argument can be used as; tail(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; to show the last 6 records while specifying n value will show the specified number of rows. R identifies this type of data as table or data frame. class(hg) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str() is used to find the nature of data such as column data types, number of rows and columns, column names , and first records in the dataframe str(hg) ## tibble [25 × 8] (S3: tbl_df/tbl/data.frame) ## $ Chromosome : chr [1:25] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Base_Pairs : num [1:25] 2.49e+08 2.42e+08 1.98e+08 1.90e+08 1.82e+08 ... ## $ Protein_Coding_genes : num [1:25] 2058 1309 1078 752 876 ... ## $ Pseudogenes : num [1:25] 1220 1023 763 727 721 ... ## $ Total_long_non_coding_RNA: num [1:25] 1200 1037 711 657 844 ... ## $ Total_small_nc_RA : num [1:25] 496 375 298 228 235 234 208 214 190 204 ... ## $ miRNA : num [1:25] 134 115 99 92 83 81 90 80 69 64 ... ## $ rRNA : num [1:25] 66 40 29 24 25 26 24 28 19 32 ... is.na() is used to check if there is null/blank values in the dataset. If there is it returns TRUE in place of the null point while it return FALSE in place of the value. sum(is.na(hg)) ## [1] 0 The “hg” data frame has no null values. Lets dive into biology to solve some of the questions about genetics Q1. Calculate the gene densityfor each chromosome The gene density is calculated in terms of genes per megabase base_Mb = hg$Base_Pairs/1000000 base_Mb ## [1] 248.956422 242.193529 198.295559 190.214555 181.538259 170.805979 ## [7] 159.345973 145.138636 138.394717 133.797422 135.086622 133.275309 ## [13] 114.364328 107.043718 101.991189 90.338345 83.257441 80.373285 ## [19] 58.617616 64.444167 46.709983 50.818468 156.040895 57.227415 ## [25] 0.016569 To make the values more clear, the results can be rounded off to two decimal place. rbase_Mb=round(base_Mb, digits = 2) rbase_Mb ## [1] 248.96 242.19 198.30 190.21 181.54 170.81 159.35 145.14 138.39 133.80 ## [11] 135.09 133.28 114.36 107.04 101.99 90.34 83.26 80.37 58.62 64.44 ## [21] 46.71 50.82 156.04 57.23 0.02 Q2. Calculate number of genes per megabase per chromosomes The protein coding genes are divided to the gene density. genes_per_megabase = round(hg$Protein_Coding_genes/base_Mb, digits = 2) genes_per_megabase ## [1] 8.27 5.40 5.44 3.95 4.83 6.14 6.21 4.66 5.68 5.48 ## [11] 9.61 7.76 2.86 7.75 6.01 9.66 14.38 3.36 25.11 8.44 ## [21] 5.01 9.60 5.40 1.24 784.60 Lets create a new column to the dataframe to the dataset hg[&quot;genes_per_Mb&quot;]=genes_per_megabase str(hg) ## tibble [25 × 9] (S3: tbl_df/tbl/data.frame) ## $ Chromosome : chr [1:25] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Base_Pairs : num [1:25] 2.49e+08 2.42e+08 1.98e+08 1.90e+08 1.82e+08 ... ## $ Protein_Coding_genes : num [1:25] 2058 1309 1078 752 876 ... ## $ Pseudogenes : num [1:25] 1220 1023 763 727 721 ... ## $ Total_long_non_coding_RNA: num [1:25] 1200 1037 711 657 844 ... ## $ Total_small_nc_RA : num [1:25] 496 375 298 228 235 234 208 214 190 204 ... ## $ miRNA : num [1:25] 134 115 99 92 83 81 90 80 69 64 ... ## $ rRNA : num [1:25] 66 40 29 24 25 26 24 28 19 32 ... ## $ genes_per_Mb : num [1:25] 8.27 5.4 5.44 3.95 4.83 6.14 6.21 4.66 5.68 5.48 ... 4.1.2 Write a new table to a file locally The write.table() function is used to write table to file on a local machine. The file is saved by deault to the working directory unless the path is specified. write.table(hg, file=&quot;data/hg_modified&quot;, quote=FALSE, sep=&#39;\\t&#39;, row.names=FALSE, col.names=TRUE) This file will be saved by default on the working directory unless the file path is changed. Checking if the new file is saved. file.show(&quot;data/hg_modified&quot;) 4.2 .CSV files CSV stands for “Comma Separated Values”. This is a plain text file that contains data in a tabular format for example the data below that represents athletes’ statistics. Name, Age, Weight Salman, 30, 75 Pragya, 35, 72 Vidyat, 25, 68 Each line in a CSV file represents a row while each field in a row is separated by a comma “,”. These files are often used in data manipulations since they are lightweight, simple and widely supported. In this course we shall briefly go through two csv files and do brief analyses. 4.2.1 Titanic dataset The titanic data is a famous data set in data analysis. It contains information about passengers that boarded the ship Titan(not actual true) including their age, ticket class, fare and others. 4.2.1.1 Reading the csv file The read.csv() function is used to read a csv file to a data frame. # Read data from a CSV file into a data frame titanic_df = read.csv(&quot;data/titanic_dataset.csv&quot;) 4.2.1.2 Data Assessment Structure of the dataset str(titanic_df) ## &#39;data.frame&#39;: 418 obs. of 12 variables: ## $ PassengerId: int 892 893 894 895 896 897 898 899 900 901 ... ## $ Survived : int 0 1 0 0 1 0 1 0 1 0 ... ## $ Pclass : int 3 3 2 3 3 3 3 2 3 3 ... ## $ Name : chr &quot;Kelly, Mr. James&quot; &quot;Wilkes, Mrs. James (Ellen Needs)&quot; &quot;Myles, Mr. Thomas Francis&quot; &quot;Wirz, Mr. Albert&quot; ... ## $ Sex : chr &quot;male&quot; &quot;female&quot; &quot;male&quot; &quot;male&quot; ... ## $ Age : num 34.5 47 62 27 22 14 30 26 18 21 ... ## $ SibSp : int 0 1 0 0 1 0 0 1 0 2 ... ## $ Parch : int 0 0 0 0 1 0 0 1 0 0 ... ## $ Ticket : chr &quot;330911&quot; &quot;363272&quot; &quot;240276&quot; &quot;315154&quot; ... ## $ Fare : num 7.83 7 9.69 8.66 12.29 ... ## $ Cabin : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Embarked : chr &quot;Q&quot; &quot;S&quot; &quot;Q&quot; &quot;S&quot; ... Show the first 6 records of the data set. head(titanic_df) ## PassengerId Survived Pclass Name ## 1 892 0 3 Kelly, Mr. James ## 2 893 1 3 Wilkes, Mrs. James (Ellen Needs) ## 3 894 0 2 Myles, Mr. Thomas Francis ## 4 895 0 3 Wirz, Mr. Albert ## 5 896 1 3 Hirvonen, Mrs. Alexander (Helga E Lindqvist) ## 6 897 0 3 Svensson, Mr. Johan Cervin ## Sex Age SibSp Parch Ticket Fare Cabin Embarked ## 1 male 34.5 0 0 330911 7.8292 Q ## 2 female 47.0 1 0 363272 7.0000 S ## 3 male 62.0 0 0 240276 9.6875 Q ## 4 male 27.0 0 0 315154 8.6625 S ## 5 female 22.0 1 1 3101298 12.2875 S ## 6 male 14.0 0 0 7538 9.2250 S Count the null values in the data sum(is.na(titanic_df)) ## [1] 87 The are 87 fields in the data that are null(empty) Calculate the descriptive statistics summary(titanic_df) ## PassengerId Survived Pclass Name ## Min. : 892.0 Min. :0.0000 Min. :1.000 Length:418 ## 1st Qu.: 996.2 1st Qu.:0.0000 1st Qu.:1.000 Class :character ## Median :1100.5 Median :0.0000 Median :3.000 Mode :character ## Mean :1100.5 Mean :0.3636 Mean :2.266 ## 3rd Qu.:1204.8 3rd Qu.:1.0000 3rd Qu.:3.000 ## Max. :1309.0 Max. :1.0000 Max. :3.000 ## ## Sex Age SibSp Parch ## Length:418 Min. : 0.17 Min. :0.0000 Min. :0.0000 ## Class :character 1st Qu.:21.00 1st Qu.:0.0000 1st Qu.:0.0000 ## Mode :character Median :27.00 Median :0.0000 Median :0.0000 ## Mean :30.27 Mean :0.4474 Mean :0.3923 ## 3rd Qu.:39.00 3rd Qu.:1.0000 3rd Qu.:0.0000 ## Max. :76.00 Max. :8.0000 Max. :9.0000 ## NA&#39;s :86 ## Ticket Fare Cabin Embarked ## Length:418 Min. : 0.000 Length:418 Length:418 ## Class :character 1st Qu.: 7.896 Class :character Class :character ## Mode :character Median : 14.454 Mode :character Mode :character ## Mean : 35.627 ## 3rd Qu.: 31.500 ## Max. :512.329 ## NA&#39;s :1 4.2.1.3 Data Analysis The answers to the two questions will give a brief understanding of titanic passengers. What is the survival rate by gender? # Survival rate by gender table(titanic_df$Sex, titanic_df$Survived) ## ## 0 1 ## female 0 152 ## male 266 0 From the table above, all males drowned but all females survived. What is the survival rate by ticket class? # Survival rate by ticket class table(titanic_df$Pclass, titanic_df$Survived) ## ## 0 1 ## 1 57 50 ## 2 63 30 ## 3 146 72 Most passengers from ticket class 0 survived. 4.2.2 IBM Employee Attrition data This is a common data set used for HR analytics. It contains information about all IBM employees, who are still in the company and the ones who left. Analyzing this attrition data set will provide meaningful insights on employees’ behavior and their engagement. HR can also find employee retention techniques with organizations. In this course section, we will briefly go through basic analysis after assessing the data. 4.2.2.1 Reading the csv file attrition_df = read.csv(&quot;data/HR-Employee-Attrition.csv&quot;) 4.2.2.2 Data Assessment Structure of the data str(attrition_df) ## &#39;data.frame&#39;: 1470 obs. of 35 variables: ## $ Age : int 41 49 37 33 27 32 59 30 38 36 ... ## $ Attrition : chr &quot;Yes&quot; &quot;No&quot; &quot;Yes&quot; &quot;No&quot; ... ## $ BusinessTravel : chr &quot;Travel_Rarely&quot; &quot;Travel_Frequently&quot; &quot;Travel_Rarely&quot; &quot;Travel_Frequently&quot; ... ## $ DailyRate : int 1102 279 1373 1392 591 1005 1324 1358 216 1299 ... ## $ Department : chr &quot;Sales&quot; &quot;Research &amp; Development&quot; &quot;Research &amp; Development&quot; &quot;Research &amp; Development&quot; ... ## $ DistanceFromHome : int 1 8 2 3 2 2 3 24 23 27 ... ## $ Education : int 2 1 2 4 1 2 3 1 3 3 ... ## $ EducationField : chr &quot;Life Sciences&quot; &quot;Life Sciences&quot; &quot;Other&quot; &quot;Life Sciences&quot; ... ## $ EmployeeCount : int 1 1 1 1 1 1 1 1 1 1 ... ## $ EmployeeNumber : int 1 2 4 5 7 8 10 11 12 13 ... ## $ EnvironmentSatisfaction : int 2 3 4 4 1 4 3 4 4 3 ... ## $ Gender : chr &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; ... ## $ HourlyRate : int 94 61 92 56 40 79 81 67 44 94 ... ## $ JobInvolvement : int 3 2 2 3 3 3 4 3 2 3 ... ## $ JobLevel : int 2 2 1 1 1 1 1 1 3 2 ... ## $ JobRole : chr &quot;Sales Executive&quot; &quot;Research Scientist&quot; &quot;Laboratory Technician&quot; &quot;Research Scientist&quot; ... ## $ JobSatisfaction : int 4 2 3 3 2 4 1 3 3 3 ... ## $ MaritalStatus : chr &quot;Single&quot; &quot;Married&quot; &quot;Single&quot; &quot;Married&quot; ... ## $ MonthlyIncome : int 5993 5130 2090 2909 3468 3068 2670 2693 9526 5237 ... ## $ MonthlyRate : int 19479 24907 2396 23159 16632 11864 9964 13335 8787 16577 ... ## $ NumCompaniesWorked : int 8 1 6 1 9 0 4 1 0 6 ... ## $ Over18 : chr &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; ... ## $ OverTime : chr &quot;Yes&quot; &quot;No&quot; &quot;Yes&quot; &quot;Yes&quot; ... ## $ PercentSalaryHike : int 11 23 15 11 12 13 20 22 21 13 ... ## $ PerformanceRating : int 3 4 3 3 3 3 4 4 4 3 ... ## $ RelationshipSatisfaction: int 1 4 2 3 4 3 1 2 2 2 ... ## $ StandardHours : int 80 80 80 80 80 80 80 80 80 80 ... ## $ StockOptionLevel : int 0 1 0 0 1 0 3 1 0 2 ... ## $ TotalWorkingYears : int 8 10 7 8 6 8 12 1 10 17 ... ## $ TrainingTimesLastYear : int 0 3 3 3 3 2 3 2 2 3 ... ## $ WorkLifeBalance : int 1 3 3 3 3 2 2 3 3 2 ... ## $ YearsAtCompany : int 6 10 0 8 2 7 1 1 9 7 ... ## $ YearsInCurrentRole : int 4 7 0 7 2 7 0 0 7 7 ... ## $ YearsSinceLastPromotion : int 0 1 0 3 2 3 0 0 1 7 ... ## $ YearsWithCurrManager : int 5 7 0 0 2 6 0 0 8 7 ... Most columns have character and integer values. Shape of the data set dim(attrition_df) ## [1] 1470 35 There are 1470 rows and 35 variables in the data set. Lets now show the first few rows of the data to get the idea of how the data looks like. head(attrition_df) ## Age Attrition BusinessTravel DailyRate Department ## 1 41 Yes Travel_Rarely 1102 Sales ## 2 49 No Travel_Frequently 279 Research &amp; Development ## 3 37 Yes Travel_Rarely 1373 Research &amp; Development ## 4 33 No Travel_Frequently 1392 Research &amp; Development ## 5 27 No Travel_Rarely 591 Research &amp; Development ## 6 32 No Travel_Frequently 1005 Research &amp; Development ## DistanceFromHome Education EducationField EmployeeCount EmployeeNumber ## 1 1 2 Life Sciences 1 1 ## 2 8 1 Life Sciences 1 2 ## 3 2 2 Other 1 4 ## 4 3 4 Life Sciences 1 5 ## 5 2 1 Medical 1 7 ## 6 2 2 Life Sciences 1 8 ## EnvironmentSatisfaction Gender HourlyRate JobInvolvement JobLevel ## 1 2 Female 94 3 2 ## 2 3 Male 61 2 2 ## 3 4 Male 92 2 1 ## 4 4 Female 56 3 1 ## 5 1 Male 40 3 1 ## 6 4 Male 79 3 1 ## JobRole JobSatisfaction MaritalStatus MonthlyIncome MonthlyRate ## 1 Sales Executive 4 Single 5993 19479 ## 2 Research Scientist 2 Married 5130 24907 ## 3 Laboratory Technician 3 Single 2090 2396 ## 4 Research Scientist 3 Married 2909 23159 ## 5 Laboratory Technician 2 Married 3468 16632 ## 6 Laboratory Technician 4 Single 3068 11864 ## NumCompaniesWorked Over18 OverTime PercentSalaryHike PerformanceRating ## 1 8 Y Yes 11 3 ## 2 1 Y No 23 4 ## 3 6 Y Yes 15 3 ## 4 1 Y Yes 11 3 ## 5 9 Y No 12 3 ## 6 0 Y No 13 3 ## RelationshipSatisfaction StandardHours StockOptionLevel TotalWorkingYears ## 1 1 80 0 8 ## 2 4 80 1 10 ## 3 2 80 0 7 ## 4 3 80 0 8 ## 5 4 80 1 6 ## 6 3 80 0 8 ## TrainingTimesLastYear WorkLifeBalance YearsAtCompany YearsInCurrentRole ## 1 0 1 6 4 ## 2 3 3 10 7 ## 3 3 3 0 0 ## 4 3 3 8 7 ## 5 3 3 2 2 ## 6 2 2 7 7 ## YearsSinceLastPromotion YearsWithCurrManager ## 1 0 5 ## 2 1 7 ## 3 0 0 ## 4 3 0 ## 5 2 2 ## 6 3 6 It is also important when analyzing data to find the existence of null fields and duplicated records. Are there any null values? sum(is.na(attrition_df)) ## [1] 0 The data is complete with no null values. Are there any duplicated rows? sum(duplicated(attrition_df)) ## [1] 0 Also, all the rows are unique and there is no duplicated row in the data. 4.2.2.3 Data Analysis The following questions will enable us to get a brief overview of the company; What are the unique departments in the company? unique(attrition_df$Department) ## [1] &quot;Sales&quot; &quot;Research &amp; Development&quot; &quot;Human Resources&quot; There are three distinct departments in the company data; Human Resources, Sales, and Research &amp; Development. Is there a difference in attrition rates between genders? # Table of attrition by gender table(attrition_df$Gender, attrition_df$Attrition) ## ## No Yes ## Female 501 87 ## Male 732 150 From the table, we can see the number of males and females who have left the company (Attrition=Yes) and those who are still employed (Attrition=No) What is the attrition rate among employees in different job roles? # Table of attrition by job role table(attrition_df$JobRole, attrition_df$Attrition) ## ## No Yes ## Healthcare Representative 122 9 ## Human Resources 40 12 ## Laboratory Technician 197 62 ## Manager 97 5 ## Manufacturing Director 135 10 ## Research Director 78 2 ## Research Scientist 245 47 ## Sales Executive 269 57 ## Sales Representative 50 33 From the table above there is a high attrition rate among Laboratory technicians(62) and Sales Executives(57) while lowest attrition rate among Research directors(2) and Managers(5). Does age impact attrition rate? To find a clear answer to this, the ages will be summarized into different groups and create a table comparing the attrition and retention rates among different age groups. # Table of attrition by age group attrition_df$AgeGroup &lt;- cut(attrition_df$Age, breaks = c(0, 30, 40, 50, 60, 70), labels = c(&quot;0-30&quot;, &quot;31-40&quot;, &quot;41-50&quot;, &quot;51-60&quot;, &quot;61-70&quot;)) # Create a table table(attrition_df$AgeGroup, attrition_df$Attrition) ## ## No Yes ## 0-30 286 100 ## 31-40 534 85 ## 41-50 288 34 ## 51-60 125 18 ## 61-70 0 0 Young employees below 30 years tend to leave the company than elder employees of above 40 years who are mostly retained by the company. "],["dpyr-library.html", "Chapter 5 Dpyr library 5.1 Dplyr Verbs 5.2 Chaining 5.3 Application of Dplyr on Microbiology", " Chapter 5 Dpyr library readxl library has been used to read excel table into R and manipulate the data using R basic functions, now dplyr library will be used. This, dplyr library is an advanced package that has functions used to manipulate data. The functions are referred to as dplyr verbs. This are some of the examples of dplyr verbs; - select - filter - arrange - mutate - group by - summarise To install dplyr, run the below command on the console. install.packages(&quot;dplyr&quot;) Ensure your computer is connected to the internet when installing! To invoke the libraries to the program run; library(dplyr) library(readxl) Before working on the data, it need to imported first. The readxl library will be used. The data will then be manipulated by dplyr. Apart from data retrieved from excel tables, there are some inbuilt freely available datasets in R that a student can use for practice. data() function can be used to view some of the freely available datasets in R. data() This will show all data sets including both the inbuilt and the previously imported ones. Alternatively the code below will show only the inbuilt R data sets. ls(&quot;package:datasets&quot;) ## [1] &quot;ability.cov&quot; &quot;airmiles&quot; &quot;AirPassengers&quot; ## [4] &quot;airquality&quot; &quot;anscombe&quot; &quot;attenu&quot; ## [7] &quot;attitude&quot; &quot;austres&quot; &quot;beaver1&quot; ## [10] &quot;beaver2&quot; &quot;BJsales&quot; &quot;BJsales.lead&quot; ## [13] &quot;BOD&quot; &quot;cars&quot; &quot;ChickWeight&quot; ## [16] &quot;chickwts&quot; &quot;co2&quot; &quot;CO2&quot; ## [19] &quot;crimtab&quot; &quot;discoveries&quot; &quot;DNase&quot; ## [22] &quot;esoph&quot; &quot;euro&quot; &quot;euro.cross&quot; ## [25] &quot;eurodist&quot; &quot;EuStockMarkets&quot; &quot;faithful&quot; ## [28] &quot;fdeaths&quot; &quot;Formaldehyde&quot; &quot;freeny&quot; ## [31] &quot;freeny.x&quot; &quot;freeny.y&quot; &quot;HairEyeColor&quot; ## [34] &quot;Harman23.cor&quot; &quot;Harman74.cor&quot; &quot;Indometh&quot; ## [37] &quot;infert&quot; &quot;InsectSprays&quot; &quot;iris&quot; ## [40] &quot;iris3&quot; &quot;islands&quot; &quot;JohnsonJohnson&quot; ## [43] &quot;LakeHuron&quot; &quot;ldeaths&quot; &quot;lh&quot; ## [46] &quot;LifeCycleSavings&quot; &quot;Loblolly&quot; &quot;longley&quot; ## [49] &quot;lynx&quot; &quot;mdeaths&quot; &quot;morley&quot; ## [52] &quot;mtcars&quot; &quot;nhtemp&quot; &quot;Nile&quot; ## [55] &quot;nottem&quot; &quot;npk&quot; &quot;occupationalStatus&quot; ## [58] &quot;Orange&quot; &quot;OrchardSprays&quot; &quot;PlantGrowth&quot; ## [61] &quot;precip&quot; &quot;presidents&quot; &quot;pressure&quot; ## [64] &quot;Puromycin&quot; &quot;quakes&quot; &quot;randu&quot; ## [67] &quot;rivers&quot; &quot;rock&quot; &quot;Seatbelts&quot; ## [70] &quot;sleep&quot; &quot;stack.loss&quot; &quot;stack.x&quot; ## [73] &quot;stackloss&quot; &quot;state.abb&quot; &quot;state.area&quot; ## [76] &quot;state.center&quot; &quot;state.division&quot; &quot;state.name&quot; ## [79] &quot;state.region&quot; &quot;state.x77&quot; &quot;sunspot.month&quot; ## [82] &quot;sunspot.year&quot; &quot;sunspots&quot; &quot;swiss&quot; ## [85] &quot;Theoph&quot; &quot;Titanic&quot; &quot;ToothGrowth&quot; ## [88] &quot;treering&quot; &quot;trees&quot; &quot;UCBAdmissions&quot; ## [91] &quot;UKDriverDeaths&quot; &quot;UKgas&quot; &quot;USAccDeaths&quot; ## [94] &quot;USArrests&quot; &quot;UScitiesD&quot; &quot;USJudgeRatings&quot; ## [97] &quot;USPersonalExpenditure&quot; &quot;uspop&quot; &quot;VADeaths&quot; ## [100] &quot;volcano&quot; &quot;warpbreaks&quot; &quot;women&quot; ## [103] &quot;WorldPhones&quot; &quot;WWWusage&quot; Some libraries come with their own inbuilt data sets which can be explored by the command; data(package=.packages(all.available = TRUE)) Good example is the famous iris that will be used in this course. It is always used by beginners in data science. The data set contains measurements of various characteristics of iris flowers. These characteristics include sepal length, sepal width, petal length, and petal width. There are three species of iris flowers in the data set: setosa, versicolor, and virginica. The data will be invoked to R before assessment and wrangling; Lets load the iris data and explore the first few records. data(&quot;iris&quot;) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Calculating the summary statistics summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Lets write this data set locally to a file. write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) or to remove quotes next to values write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE, quote = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) or to remove quotes and row names write.table(iris, &quot;data/iris_dataset.txt&quot;, append = FALSE, quote=FALSE, row.names = FALSE) file.show(&quot;data/iris_dataset.txt&quot;) 5.1 Dplyr Verbs 5.1.1 select This dplyr verb is used when selecting or dropping specific columns. In this lesson we will find the iris column names and select two of them using select. # Find the column names colnames(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; Remember the data frame to work on need to be specified in the arguments such that selected_data = select(data_frame, col1, col2, col3) Therefore, we will select the columns; Species, Petal length and petal width. selected_iris_data = select(iris, Petal.Length, Petal.Width, Species) # view the first few rows of the selected data head(selected_iris_data) ## Petal.Length Petal.Width Species ## 1 1.4 0.2 setosa ## 2 1.4 0.2 setosa ## 3 1.3 0.2 setosa ## 4 1.5 0.2 setosa ## 5 1.4 0.2 setosa ## 6 1.7 0.4 setosa The three selected columns are displayed in the data frame above. Specific columns can be dropped by putting - before the column name as # Drop specified columns remaining_data = select(data_frame, -col1_to_drop, -col2_to_drop) In this lesson, we will drop petal length, petal width and Species columns; remaining_iris_data = select(iris, -Petal.Length, -Petal.Width, -Species) # view the first few rows of the selected data head(remaining_iris_data) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 5.1.2 filter Is a verb/function from dplyr used to filter records in a data frame based on a specific condition. It allows the analyst to retrieve the records he/she is interested in and work easier with the subset. With filter(), the data frame and the condion are passed as a arguments; # Filtering rows where a certain column meets a condition filtered_data = filter(data_frame, column_name &gt; 5 # This is the condition) Lets select the species ‘setosa’ from the iris data set setosa_iris = filter(iris, # the data frame Species == &quot;setosa&quot; # the condition ) # First few records of setosa data head(setosa_iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Records with sepal width of more than 3.0 can be filtered. Here is how we achieve such a subset wide_sepal_iris = filter(iris, #the data frame Sepal.Width&gt;3.0 # the condition ) head(wide_sepal_iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.7 3.2 1.3 0.2 setosa ## 3 4.6 3.1 1.5 0.2 setosa ## 4 5.0 3.6 1.4 0.2 setosa ## 5 5.4 3.9 1.7 0.4 setosa ## 6 4.6 3.4 1.4 0.3 setosa 5.1.3 arrange This is dplyr verb/function used for sorting rows by rearranging in a specific order. here is how to use arrange() function; arranged_data = arrange(data_frame, column_name) This allows the analyst to arrange the data in a default ascending order. To arrange in a descending order a desc() function is added as; # Note the additional desc function arranged_data = arrange(data_frame, desc(column_name)) Now lets order the iris data in an ascending order based on Petal length and view the first 6 records with the shortest petal. # Sort the data by_petal_length = arrange(iris, # data frame Petal.Length # order by column ) # View the data head(by_petal_length) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 4.6 3.6 1.0 0.2 setosa ## 2 4.3 3.0 1.1 0.1 setosa ## 3 5.8 4.0 1.2 0.2 setosa ## 4 5.0 3.2 1.2 0.2 setosa ## 5 4.7 3.2 1.3 0.2 setosa ## 6 5.4 3.9 1.3 0.4 setosa Lets repeat the same process but now we order the data in a descending order. # Sort the data by_petal_length = arrange(iris, # data frame desc(Petal.Length) # order by column ) # View the data head(by_petal_length) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.7 2.6 6.9 2.3 virginica ## 2 7.7 3.8 6.7 2.2 virginica ## 3 7.7 2.8 6.7 2.0 virginica ## 4 7.6 3.0 6.6 2.1 virginica ## 5 7.9 3.8 6.4 2.0 virginica ## 6 7.3 2.9 6.3 1.8 virginica 5.1.4 mutate mutate() is a dplyr verb used to modifying the existing variables or creating new variables in a data set. In this case we can calculate the log off Sepal length in the iris data # modify Sepal.Length new_iris = mutate(iris, Sepal.Length=log(Sepal.Length)) head(new_iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 1.629241 3.5 1.4 0.2 setosa ## 2 1.589235 3.0 1.4 0.2 setosa ## 3 1.547563 3.2 1.3 0.2 setosa ## 4 1.526056 3.1 1.5 0.2 setosa ## 5 1.609438 3.6 1.4 0.2 setosa ## 6 1.686399 3.9 1.7 0.4 setosa Additionally, we can create an entirely new variable by mutate(). In this case we will find the ratio between petal length and petal width. The new variable will be called “Petal.Length.Width.Ratio” new_iris = mutate(iris, Petal.Length.Width.Ratio = Petal.Length/Petal.Width) head(new_iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## Petal.Length.Width.Ratio ## 1 7.00 ## 2 7.00 ## 3 6.50 ## 4 7.50 ## 5 7.00 ## 6 4.25 The “Petal.Length.Width.Ratio” is found by dividing the Petal.Length and the Petal.Width variables. 5.1.5 group_by The group_by() is a function used to group records in a data frame by one or more variables. It allows the analyst to create a group based on a certain criteria. Lets group the iris data based on the Species variable; iris_groups = group_by(iris, Species) head(iris_groups) ## # A tibble: 6 × 5 ## # Groups: Species [1] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa This groupings allow the analyst to retrieve insights at more base level and uncover more insights that could not have been possible when analyzing the entire data set 5.1.6 Summarise To calculate summary statistics such as average, median and maximum the summarise() is used. This function collapses mutilple rows into a summary row. For instance calculating the mean Petal width; summarise(iris, mean_petal_width=mean(Petal.Width)) ## mean_petal_width ## 1 1.199333 To find the mean petal width for each iris species; - the iris data will be grouped by species - a mean value for each group will be calculated grouped_iris = group_by(iris, Species) mean_petal_widths = summarise(grouped_iris, mean_value=mean(Petal.Width)) mean_petal_widths ## # A tibble: 3 × 2 ## Species mean_value ## &lt;fct&gt; &lt;dbl&gt; ## 1 setosa 0.246 ## 2 versicolor 1.33 ## 3 virginica 2.03 5.2 Chaining Chaining is the process of combining several operations together using the %&gt;% or forward pipe operator. The chained workflow succeeds each other until the whole process is done. To understand chaining, the mtcars(Motor Trend cars) data set will be used. Mtcars is also a well-known data set containing several attributes of 32 different cars from 1974. Here’s a brief explanation of the variables in the mtcars data set: mpg: Miles per gallon (fuel efficiency). cyl: Number of cylinders. disp: Displacement (cubic inches). hp: Horsepower. drat: Rear axle ratio. wt: Weight (in 1000 lbs). qsec: Quarter mile time (in seconds). vs: Engine type (0 = V-shaped, 1 = Straight). am: Transmission type (0 = Automatic, 1 = Manual). gear: Number of forward gears. carb: Number of carburetors. Lets start by loading the data into the program and view its first few records; data(mtcars) head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Lets select 6 most important columns in this analysis cars1 = mtcars %&gt;% select(mpg, cyl, disp, hp, qsec, am) head(cars1) ## mpg cyl disp hp qsec am ## Mazda RX4 21.0 6 160 110 16.46 1 ## Mazda RX4 Wag 21.0 6 160 110 17.02 1 ## Datsun 710 22.8 4 108 93 18.61 1 ## Hornet 4 Drive 21.4 6 258 110 19.44 0 ## Hornet Sportabout 18.7 8 360 175 17.02 0 ## Valiant 18.1 6 225 105 20.22 0 Lets now filter to find vehicles with an automatic transmission type. The filter verb will be chained to select verb with %&gt;%. cars2 = mtcars %&gt;%select(mpg, cyl, disp, hp, qsec, am) %&gt;% filter(am==0) head(cars2) ## mpg cyl disp hp qsec am ## Hornet 4 Drive 21.4 6 258.0 110 19.44 0 ## Hornet Sportabout 18.7 8 360.0 175 17.02 0 ## Valiant 18.1 6 225.0 105 20.22 0 ## Duster 360 14.3 8 360.0 245 15.84 0 ## Merc 240D 24.4 4 146.7 62 20.00 0 ## Merc 230 22.8 4 140.8 95 22.90 0 All these vehicles are of automatic transmission type, lets rank them according to the horsepower in descending order. cars3= mtcars %&gt;%select(mpg, cyl, disp, hp, qsec, am, wt) %&gt;% filter(am==0) %&gt;% arrange(desc(hp)) head(cars3) ## mpg cyl disp hp qsec am wt ## Duster 360 14.3 8 360.0 245 15.84 0 3.570 ## Camaro Z28 13.3 8 350.0 245 15.41 0 3.840 ## Chrysler Imperial 14.7 8 440.0 230 17.42 0 5.345 ## Lincoln Continental 10.4 8 460.0 215 17.82 0 5.424 ## Cadillac Fleetwood 10.4 8 472.0 205 17.98 0 5.250 ## Merc 450SE 16.4 8 275.8 180 17.40 0 4.070 A new column of weight in 1000kgs (wt_1000kgs) can be created by diving weight in 1000lbs by 2.20462. mutate verb will be chained also. cars4= mtcars %&gt;%select(mpg, cyl, disp, hp, qsec, am, wt) %&gt;% filter(am==0) %&gt;% arrange(desc(hp)) %&gt;% mutate(wt_1000kgs=wt/2.20462) head(cars4) ## mpg cyl disp hp qsec am wt wt_1000kgs ## Duster 360 14.3 8 360.0 245 15.84 0 3.570 1.619327 ## Camaro Z28 13.3 8 350.0 245 15.41 0 3.840 1.741797 ## Chrysler Imperial 14.7 8 440.0 230 17.42 0 5.345 2.424454 ## Lincoln Continental 10.4 8 460.0 215 17.82 0 5.424 2.460288 ## Cadillac Fleetwood 10.4 8 472.0 205 17.98 0 5.250 2.381363 ## Merc 450SE 16.4 8 275.8 180 17.40 0 4.070 1.846123 The above process has explained how chained works in dplyr. Many functions/processed can be chained together to manipulate data to the desired output. The next section will apply chaining to biology and be used to answer a few questions that will cement your understanding in R as a biologist. 5.3 Application of Dplyr on Microbiology Genetics composition of an organism can be analyzed using dplyr, in this course unit it will be used to analyze the human genetics data. Read the data set from a file into a data frame hg = read_excel(&quot;data/Human_genome.xlsx&quot;) class(hg) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; review the first six records of the data set head(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; the last six records of the data set tail(hg) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20 64444167 544 249 384 ## 2 21 46709983 234 185 305 ## 3 22 50818468 488 324 357 ## 4 X 156040895 842 874 271 ## 5 Y 57227415 71 388 71 ## 6 mtDNA 16569 13 0 0 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; sample_n() command is used to randomly sample fixed number of rows from the data frame. Lets sample five rows randomly hg %&gt;% sample_n(5) ## # A tibble: 5 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 13 114364328 327 372 397 ## 2 16 90338345 873 465 799 ## 3 Y 57227415 71 388 71 ## 4 6 170805979 1048 801 639 ## 5 1 248956422 2058 1220 1200 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; sample_fra() command can also be used to extract a percent of rows randomly. Lets samople 25% of the rows hg %&gt;% sample_frac(0.25, replace = FALSE) ## # A tibble: 6 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 22 50818468 488 324 357 ## 2 16 90338345 873 465 799 ## 3 14 107043718 830 523 533 ## 4 9 138394717 786 661 491 ## 5 2 242193529 1309 1023 1037 ## 6 15 101991189 613 510 639 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; The replace argument allows repetition of rows when sampling when set TRUE and vice versa. The essence of dplyr in microbiology data can be explained better by questions. Q1. Which chromosomes has maximum size The functions used here are; select, arrange, slice The required columns will be selected i.e Chromosomes and Base_Pairs(size) The data will ordered according to Base_Pairs in descending order by the arrange command. the data will be “sliced” to select the first row All these processes will be chained to run progressively from process 1 to 3. All the above steps should be piped hg1 = hg %&gt;% #transfer the data to a new variable select(Chromosome, Base_Pairs) %&gt;% # select the required columns arrange(desc(Base_Pairs)) %&gt;% #order in descending order slice(1) hg1 ## # A tibble: 1 × 2 ## Chromosome Base_Pairs ## &lt;chr&gt; &lt;dbl&gt; ## 1 1 248956422 Q2. List of Chromosomes with more than 500 pseudogenes and more than 1000 protein coding genes The human genome data frame will be filtered to find the Chromosomes with more than 500 pseudogenes and more than 1000 protein coding genes. &amp; condition is used in the filter hg2=hg%&gt;% filter(Pseudogenes&gt;500 &amp; Protein_Coding_genes&gt;1000) hg2 ## # A tibble: 8 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 6 170805979 1048 801 639 ## 5 11 135086622 1298 821 710 ## 6 12 133275309 1034 617 848 ## 7 17 83257441 1197 531 834 ## 8 19 58617616 1472 512 628 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Q3. List of Chromosomes with more tha 500 pseudogenes or more than 1000 protein coding genes and miRNA more than 100 a frame will be filtered to find the Chromosomes with more than 500 pseudogenes The human genome dator more than 1000 protein coding genes and mtRNA more than 100. The &amp; and | conditions will be used in place of “and” and “or” respectively. hg2=hg %&gt;% filter((Pseudogenes&gt;500|Protein_Coding_genes&gt;1000) &amp; miRNA&gt;100) hg2 ## # A tibble: 4 × 8 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_coding…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 19 58617616 1472 512 628 ## 4 X 156040895 842 874 271 ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 3 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt; Q4. Which 10 Chromosomes have the highest protein gene density (Genes per megabase) Mutate -&gt; is a command to create a new column Lets create a column of genes per megabase where a megabase is 1000000 base pairs hg3=hg %&gt;% mutate(Genes_per_Mb=round((Protein_Coding_genes/(Base_Pairs/100000)), digit=2)) hg3 ## # A tibble: 25 × 9 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ 15 more rows ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 4 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt;, ## # Genes_per_Mb &lt;dbl&gt; then order the data according to genes per megabse column (Genes_per_mb) in descending order and select the first 10 rows using arrange and select commands. hg4=hg3 %&gt;% arrange(desc(Genes_per_Mb)) %&gt;% # order in descending order select(Chromosome, Genes_per_Mb) %&gt;% # select the required columns slice(1:10) # select the top 10 hg4 ## # A tibble: 10 × 2 ## Chromosome Genes_per_Mb ## &lt;chr&gt; &lt;dbl&gt; ## 1 mtDNA 78.5 ## 2 19 2.51 ## 3 17 1.44 ## 4 16 0.97 ## 5 11 0.96 ## 6 22 0.96 ## 7 20 0.84 ## 8 1 0.83 ## 9 12 0.78 ## 10 14 0.78 Q5. Calculate the mean of gene density for autosomes, sex chromosomes and mitochondrial genes autosomes=rep(&quot;A&quot;, 22) #create a vector with 22 As print(autosomes) ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [20] &quot;A&quot; &quot;A&quot; &quot;A&quot; chr_class=c(autosomes, &quot;S&quot;, &quot;S&quot;, &quot;M&quot;) chr_class ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ## [20] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;S&quot; &quot;S&quot; &quot;M&quot; hg5= hg3 %&gt;% mutate(Type=chr_class) hg5 # confirm the new column &quot;Type&quot; is added ## # A tibble: 25 × 10 ## Chromosome Base_Pairs Protein_Coding_genes Pseudogenes Total_long_non_codin…¹ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 248956422 2058 1220 1200 ## 2 2 242193529 1309 1023 1037 ## 3 3 198295559 1078 763 711 ## 4 4 190214555 752 727 657 ## 5 5 181538259 876 721 844 ## 6 6 170805979 1048 801 639 ## 7 7 159345973 989 885 605 ## 8 8 145138636 677 613 735 ## 9 9 138394717 786 661 491 ## 10 10 133797422 733 568 579 ## # ℹ 15 more rows ## # ℹ abbreviated name: ¹​Total_long_non_coding_RNA ## # ℹ 5 more variables: Total_small_nc_RA &lt;dbl&gt;, miRNA &lt;dbl&gt;, rRNA &lt;dbl&gt;, ## # Genes_per_Mb &lt;dbl&gt;, Type &lt;chr&gt; Group by chromosomes and calculate the mean density hg6=hg5 %&gt;% group_by(Type) %&gt;% summarise(gene_density=mean(Genes_per_Mb)) hg6 ## # A tibble: 3 × 2 ## Type gene_density ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 0.754 ## 2 M 78.5 ## 3 S 0.33 "],["ggplot.html", "Chapter 6 GGPLOT 6.1 Five key steps to ggplot 6.2 Prepare the data for plotting - Data Assessment 6.3 Plotting 6.4 Working with inbuilt iris data", " Chapter 6 GGPLOT ggplot2 is a powerful data visualization package in R that allows you to create a wide variety of graphs and plots. It is based on the grammar of graphics, a structured approach to constructing plots that emphasizes the mapping of data to visual attributes. 6.1 Five key steps to ggplot There are 5 key steps in plotting in ggplot 1.The Setup - Read the data set, define x and y axis The Labels - Title, X and Y axis labels The Theme - Default, Black and White, colored etc. The Facets - Individual Graphs for each group in data with exactly same range The Layers or geoms - The actual plot type - e.g Bar plot, Box plot, Violin plot etc. To install ggplot, run the below command in the console. install.packages(&quot;ggplot2&quot;) 6.2 Prepare the data for plotting - Data Assessment Invoke the libraries library(ggplot2) library(data.table) Read the data using the fread function methylated_c = fread(&quot;data/R_WORKSHOP.csv&quot;, header=T, sep=&quot;,&quot;) View the first five records of the data head(methylated_c) ## Chromosome Context Count Count_in_millions ## &lt;char&gt; &lt;char&gt; &lt;int&gt; &lt;num&gt; ## 1: Chr1 CG 1394740 1.394740 ## 2: Chr2 CG 915144 0.915144 ## 3: Chr3 CG 1118062 1.118062 ## 4: Chr4 CG 879170 0.879170 ## 5: Chr5 CG 1260598 1.260598 ## 6: Chr1 CHG 1543980 1.543980 Look at the nature of the data str(methylated_c) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 15 obs. of 4 variables: ## $ Chromosome : chr &quot;Chr1&quot; &quot;Chr2&quot; &quot;Chr3&quot; &quot;Chr4&quot; ... ## $ Context : chr &quot;CG&quot; &quot;CG&quot; &quot;CG&quot; &quot;CG&quot; ... ## $ Count : int 1394740 915144 1118062 879170 1260598 1543980 988829 1225767 957674 1377407 ... ## $ Count_in_millions: num 1.395 0.915 1.118 0.879 1.261 ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; In the data set, there are numeric variables a well as character columns. There are 15 records in the data set Calculate the summary statistics summary(methylated_c) ## Chromosome Context Count Count_in_millions ## Length:15 Length:15 Min. : 879170 Min. :0.8792 ## Class :character Class :character 1st Qu.:1053446 1st Qu.:1.0534 ## Mode :character Mode :character Median :1377407 Median :1.3774 ## Mean :2857317 Mean :2.8573 ## 3rd Qu.:5025181 3rd Qu.:5.0252 ## Max. :7917805 Max. :7.9178 Do the data have null values? sum(is.na(methylated_c)) ## [1] 0 This data does not have any null values. class(methylated_c) ## [1] &quot;data.table&quot; &quot;data.frame&quot; 6.3 Plotting 6.3.1 Base set up Before plotting the data, you need to; Define the graph skeleton. This is just an empty ggplot() function without additional arguments Define the aesthetics. It defines how data should be mapped to visual properties like position, color, shape, and size Define the labels. The labels make the visualizations informative and easy to understand for the user. graph=ggplot(methylated_c, aes(x=Chromosome, y=Count_in_millions))+ #graph aesthetics labs(x=&quot;Chromosomes&quot;, y=&quot;Cytosine count in millions&quot;, title=&quot;C distribution in A thaliana&quot;) #graph labels print(graph) Define the type of graph - geoms. For this case, the graph is a bar graph. geoms() stands for ‘geometric objects’. In ggplot, there are different types of geoms to define which graph is to be plotted. Some of the examples include; geom_point() for scatter plot geom_line() for a line chart geom_density() for a density plots geom_histogram() for histograms geom_boxplot() for box plots geom_col() for bar chart geom_tile() for heat maps In this course we shall explore a few of them but the concepts applies to all of them. Now lets make our plot a bar chart. geom() function will be added to a variable graph defined above to plot a bar chart. graph1 = graph + geom_col() #plot a bar chart print(graph1) If you can remember our data, methylated_c has a column/variable “Context”. In this step, the variable “Context” will be introduced to make a stacked bar chart, therefore, the C distribution in Chromosomes based on “Context” will be plotted to add some depth to the data. graph2=graph1+aes(fill=Context) print(graph2) To make it a grouped bar chart, a position argument is introduced. graph3=graph+geom_col(position=&quot;dodge&quot;)+aes(fill=Context) print(graph3) Faceted graphs - these are related data plotted separately on the same image/diagram. The facet_grid() function is added to the variable graph3 to created faceted graphs based on the variable “Context”. graph4=graph3+facet_grid(~Context) print(graph4) GGPlot randomly select colors to paint the graph but the biologist/statistician can use predefined colors as below. graph5=graph4+scale_fill_manual(values=c(&quot;brown&quot;, &quot;blue&quot;, &quot;red&quot;)) print(graph5) The background color can be modified to ones aesthetic taste. The theme() function along with relevant arguments to make the background color of your choice, in this its light blue. graph5+theme_bw(base_size=9)+theme(panel.background = element_rect(fill=&quot;lightblue&quot;)) All of the above steps can be combined to come up with a decent graph from ggplot library. my_title = expression(paste(&quot;Cystosine distribution in &quot;, italic(&quot;Arabidopis thaliana&quot;)))#Define the title graph_final = ggplot(methylated_c, aes(x=Chromosome, y=Count_in_millions))+ labs(x=&quot;Chromosomes&quot;, title = my_title) + facet_grid(~Context) + geom_col(position=&quot;dodge&quot;)+ aes(fill=Context)+scale_fill_manual(values = c(&quot;brown&quot;, &quot;blue&quot;, &quot;red&quot;))+ theme_bw(base_size = 9)+theme(panel.background = element_rect(fill=&quot;lightblue&quot;)) print(graph_final) The expression is used to combine name italics and normal fonts - this helps biologists include botanical names in charts 6.4 Working with inbuilt iris data We have worked with iris data set before. In this topic we shall ask some questions and plot them on a box plot to cement our understanding in ggplot Plot a box plot to compare the sepal length in different iris species graph = ggplot(iris, aes(x=Species, y=Sepal.Length))+ # the graph skeleton geom_boxplot()+aes(fill=Species) # aesthetics print(graph) Virginica have higher sepal length however some virginica have less sepal length than versicolor Violin plot will show a better distribution than box plot graph = ggplot(iris, aes(x=Species, y=Sepal.Length))+ geom_violin()+aes(fill=Species) print(graph) Since some data cleaning and manipulation is required before diving deep into visualizations, a package tidyr is introduced. It can be installed by invoking the command below to the console. install.packages(&quot;tidyr&quot;) This package is a part of the tidyverse collection designed to make data cleaning and reshaping easy. It has multiple functions for instance gather(), spread(), pivot_wider(), pivot_longer(), separate(), unite() and fill(). In this section we shall not dive deep to explore tidyr package but we will borrow one of its important functions, gather() to manipulate iris data when plotting. This function, gather() is used to reshape data especially from a long format to a short format. Invoke the library library(tidyr) # can be used to convert from short format to long format Convert to a long format gather command is used to convert data into fewer columns. The columns from sepal length to petal width are to be merged to a single column called measurements #Gather from sepal length to petal width column into type and measurement column iris_long = gather(iris, type, measurement, Sepal.Length:Petal.Width, factor_key = TRUE) tail(iris_long) ## Species type measurement ## 595 virginica Petal.Width 2.5 ## 596 virginica Petal.Width 2.3 ## 597 virginica Petal.Width 1.9 ## 598 virginica Petal.Width 2.0 ## 599 virginica Petal.Width 2.3 ## 600 virginica Petal.Width 1.8 Lets plot the data to a box plot graph=ggplot(iris_long, aes(x=Species,y=measurement))+ labs(x=&quot;Species&quot;, y=&quot;Length in cm&quot;, title = &quot;variation in Petals and Sepals of Iris Species&quot;)+ theme(axis.text = element_text(angle=90))+ facet_grid(~type)+ aes(fill=Species)+ geom_boxplot() print(graph) the same can also be plotted to a violin plot graph=ggplot(iris_long, aes(x=Species,y=measurement))+ labs(x=&quot;Species&quot;, y=&quot;Length in cm&quot;, title = &quot;variation in Petals and Sepals of Iris Species&quot;)+ theme(axis.text = element_text(angle=90))+ facet_grid(~type)+ aes(fill=Species)+ geom_violin() print(graph) "],["bioconductor.html", "Chapter 7 Bioconductor 7.1 Installing BiocManager Package 7.2 Searching and Analyzing the strings 7.3 Using seqinr 7.4 Using Short Read", " Chapter 7 Bioconductor Bioconductor is a repository for high-quality, peer-reviewed software packages for the analysis and comprehension of high-throughput genomic data. It contained specific tools that handle, analyze and visualize data from high-throughput assays for instance ChIP-Seq, single-cell RNA-Seq and RNA-Seq. It provides data structures such as ExpressionSet,SummarizedExperiment, and GenomicRangesthat store and manipulate large scale genomic data. It also consists over 2000 packages just for data pre-processing, normalization, data analysis and visualization. Here are some of the popular packages in BioConductor has to offer; Biostrings: For efficient manipulation of large biological sequences. DESeq2: For differential gene expression analysis based on count data. GenomicRanges: For representing and manipulating genomic intervals and variables defined along a genome. AnnotationDbi: For handling and querying biological annotation databases. edgeR: Another popular package for differential expression analysis, particularly for RNA-Seq data. 7.1 Installing BiocManager Package To get started with Bioconductor, you need to install the BiocManager package, which facilitates the installation and management of Bioconductor packages. You can find detailed installation instructions in the official documentation. Load the required libraries library(Biostrings) After loading the necessary libraries, you can read sequence data into R. For instance, if you have sequence data stored in a multifasta file named multifasta_seq.txt, you can use the readDNAStringSet() function. seq = readDNAStringSet(&quot;data/multifasta_seq.txt&quot;) ## Warning in .Call2(&quot;fasta_index&quot;, filexp_list, nrec, skip, seek.first.rec, : ## reading FASTA file data/multifasta_seq.txt: ignored 2545 invalid one-letter ## sequence codes seq ## DNAStringSet object of length 6: ## width seq names ## [1] 844 MVVVSSCVNTTRTAYTNSTRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV2_2019 ## [2] 842 MTTSGSDDRCTTDDVANYTHTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV ## [3] 841 MVVVSSCVNTTRTAYTNSSTRGV...KGCCSCGSCCKDDDSVKGVKHYT Spike_Bat_coronav... ## [4] 834 MVVVSSCVNTTRTGGYTNSSTRG...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [5] 846 MHAVNSCVNTGRAASTNSSRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [6] 835 MKVVATVSSYTKCDDDRTANTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_WIV1_Bat_Co... Each genomic sequence can be viewed separately by indexing seq[[1]] #first genomic sequence ## 844-letter DNAString object ## seq: MVVVSSCVNTTRTAYTNSTRGVYYDKVRSSVHSTDS...MVTMCCMTSCCSCKGCCSCGSCCKDDDSVKGVKHYT seq[[2]] # second genomic sequence ## 842-letter DNAString object ## seq: MTTSGSDDRCTTDDVANYTHTSSMRGVYYDRSDTYT...VMVTCCMTSCCSCKGACSCGSCCKDDDSVKGVKHYT Convert to character to inspect its content. as.character(seq[[1]]) ## [1] &quot;MVVVSSCVNTTRTAYTNSTRGVYYDKVRSSVHSTDSNVTWHAHVSGTNGTKRDNVNDGVYASTKSNRGWGTTDSKTSVNNATNVVKVCCNDGVYYHKNNKSWMSRVYSSANNCTYVSMDGKGNKNRVKNDGYKYSKHTNVRDGSAVDGNTRTAHRSYTGDSSSGWTAGAAAYYVGYRTKYNNGTTDAVDCADSTKCTKSTVKGYTSNRVTSVRNTNCGVNATRASVYAWNRKRSNCVADYSVYNSASSTKCYGVSTKNDCTNVYADSVRGDVRAGTGKADYNYKDDTGCVAWNSNNDSKVGGNYNYYRRKSNKRDSTYAGSTCNGVGNCYSYGTNGVGYYRVVVSHAATVCGKKSTNVKNKCVNNNGTGTGVTSNKKGRDADTTDAVRDTDTCSGGVSVTGTNTSNVAVYDVNCTVVAHADTTWRVYSTGSNVTRAGCGAHVNNSYCDGAGCASYTTNSRRARSVASSAYTMSGANSVAYSNNSATNTSVTTVSMTKTSVDCTMYCGDSTCSNYGSCTNRATGAVDKNTVAVKYKTKDGGNSDSKSKRSDNKVTADAGKYGDCGDAARDCAKNGTVTDMAYTSAAGTTSGWTGAGAAAMMAYRNGGVTNVYNKANNSAGKDSSSTASAGKDVVNNAANTVKSSNGASSVNDSRDKVAVDRTGRSTYVTRAARASANAATKMSCVGSKRVDCGKGYHMSSAHGVVHVTYVAKNTTAACHDGKAHRGVVSNGTHWVTRNYTTDNTVSGNCDVVGVNNTVYDDSKDKYKNHTSDVDGDSGNASVVNKDRNVAKNNSDGKYYKWWYWGAGAVMVTMCCMTSCCSCKGCCSCGSCCKDDDSVKGVKHYT&quot; The length function from base R is used to count the number of genomic sequences. length(seq) ## [1] 6 Names of the sequences names(seq) ## [1] &quot;Spike_SARS_CoV2_2019&quot; &quot;Spike_SARS_CoV&quot; ## [3] &quot;Spike_Bat_coronavirus_RaTG13&quot; &quot;Spike_Pangolin_coronavirus_GX&quot; ## [5] &quot;Spike_Pangolin_coronavirus_GD&quot; &quot;Spike_WIV1_Bat_Coronovirus&quot; view the first 6 sequences head(seq) ## DNAStringSet object of length 6: ## width seq names ## [1] 844 MVVVSSCVNTTRTAYTNSTRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV2_2019 ## [2] 842 MTTSGSDDRCTTDDVANYTHTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_SARS_CoV ## [3] 841 MVVVSSCVNTTRTAYTNSSTRGV...KGCCSCGSCCKDDDSVKGVKHYT Spike_Bat_coronav... ## [4] 834 MVVVSSCVNTTRTGGYTNSSTRG...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [5] 846 MHAVNSCVNTGRAASTNSSRGVY...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... ## [6] 835 MKVVATVSSYTKCDDDRTANTSS...KGACSCGSCCKDDDSVKGVKHYT Spike_WIV1_Bat_Co... Checking the reverse compliment of sequence seq_rc = reverseComplement(seq[[1]]) head(seq_rc) ## 6-letter DNAString object ## seq: ARDMBC tail(seq_rc) ## 6-letter DNAString object ## seq: SSBBBK as.character(seq_rc) ## [1] &quot;ARDMBCMBSHHHMGGSCGSGGCMGSGGSAKGGKABKBTCTCWRWWMRRMCHSNNMTBNYHMNBBSTNCSHCHBHSADNMRMHMSHHRBANNBCBBHGNCSBANHAARNYABWDACNSBBCYDTMCHDGTTAANMTBRABDBBCDTSSKDRCMCGHBYMSCBGSKMATTNTSTYTTYABRASYCAYHBTBMHYSHNBSSTCNSSMBANTTNNBBHMCTSTASSSHMCTSNNTMNRBNABCCNYRTKKTTTCTCAWCSAACTTSARTKHABACNMTGHYTTHCGHCRMCTHTABMNHSYMSMSHSNCCHMAMRMBTBANMHBTCATYNAGSCRNSGASHCGRKAGHBSAMAKSBAABSANATSNNSRTBSNTCSKARTSSTBSYTYYSNAARSTGCTCHGRSNNBDTCGCTYABNSCASRBYWAAHTDTBBAGNBHRBTBNSANACABSBCCSGAHAHYBTHAAHTHYCMMNSABCACACNNNBGMNMBNASMMCGBATTDSBBBYRRCBCNACRSRGNCBCNGASCTRASHYMNSMYYRRNRNCCBMSHNNSNWTBGCAHHMRNRHTMCACTYBHCYBSHTRBNAGHNMASBCRGMASSTSNRBSRHTBGNSYMYNWTRBSTYATNBCGNANYBSABYNSARCMBASMAGMASHTGHBTHAACNNRMAYRCBRRTTTCTAWCSSSHCARSYDTAYANCHBTSCHYBNADMSRMRCHNMBYNMNCMCHKSBRAGNNTSSRBYSKWSMNNMDRRBCHNGGBMBBNATNNBSAMSHAACWCYNSMASTRBCHNBNHYMACNACSBDTDWABNSHASDBSSYBMHRRBCYASNARTAYAANBGSSBBBK&quot; Sequence composition -default - calculate the DNA composition composition=alphabetFrequency(seq) print(composition) ## A C G T M R W S Y K V H D B N - + . ## [1,] 79 40 82 97 14 42 12 99 54 61 97 17 62 0 88 0 0 0 ## [2,] 84 39 78 100 20 39 11 96 54 60 91 15 74 0 81 0 0 0 ## [3,] 80 40 82 98 14 39 12 97 55 63 94 18 64 0 85 0 0 0 ## [4,] 76 40 85 98 15 41 12 94 55 61 97 17 61 0 82 0 0 0 ## [5,] 82 40 81 99 15 40 12 100 60 58 95 14 60 0 90 0 0 0 ## [6,] 82 39 77 93 17 42 11 98 50 60 93 15 72 0 86 0 0 0 Specific composition - lets say we wanna look for A, T, G, C and N composition1=letterFrequency(seq, letters=c(&quot;A&quot;,&quot;T&quot;, &quot;G&quot;, &quot;C&quot;, &quot;N&quot;)) print(composition1) ## A T G C N ## [1,] 79 97 82 40 88 ## [2,] 84 100 78 39 81 ## [3,] 80 98 82 40 85 ## [4,] 76 98 85 40 82 ## [5,] 82 99 81 40 90 ## [6,] 82 93 77 39 86 Computing the GC Content gc_content &lt;- letterFrequency(seq, letters=&quot;GC&quot;, as.prob=TRUE) gc_content ## G|C ## [1,] 0.1445498 ## [2,] 0.1389549 ## [3,] 0.1450654 ## [4,] 0.1498801 ## [5,] 0.1430260 ## [6,] 0.1389222 Calculate the mean of Gc content mean(gc_content) ## [1] 0.1433997 Standard deviation sd(gc_content) ## [1] 0.004148188 range(gc_content) ## [1] 0.1389222 0.1498801 Which GC has the maximum content seq[which(gc_content==max(gc_content))] ## DNAStringSet object of length 1: ## width seq names ## [1] 834 MVVVSSCVNTTRTGGYTNSSTRG...KGCCSCGSCCKDDDSVKGVKHYT Spike_Pangolin_co... 7.2 Searching and Analyzing the strings A biologist can search for specific substrings within the sequences and analyze their positions and characteristics for instance; - Search for substrings- in this case we search for \"GAATTC\" substring. ECoR1=vcountPattern(&quot;GAATTC&quot;, seq) print(ECoR1) ## [1] 0 0 0 0 0 0 HindIII = vcountPattern(&quot;AAGTT&quot;, seq) print(HindIII) ## [1] 1 0 1 1 1 0 Finding the position of substrings HindIII_pos=vmatchPattern(&quot;AAGCT&quot;, seq) print(HindIII_pos) ## MIndex object of length 6 ## $Spike_SARS_CoV2_2019 ## IRanges object with 0 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## ## $Spike_SARS_CoV ## IRanges object with 0 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## ## $Spike_Bat_coronavirus_RaTG13 ## IRanges object with 0 ranges and 0 metadata columns: ## start end width ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## ## ... ## &lt;3 more elements&gt; Translate # translate(seq[[2]]) #Check functions available methods(class = &quot;DNAStringSet&quot;) ## [1] ! ## [2] != ## [3] [ ## [4] [[ ## [5] [[&lt;- ## [6] [&lt;- ## [7] %in% ## [8] &lt; ## [9] &lt;= ## [10] == ## [11] &gt; ## [12] &gt;= ## [13] $ ## [14] $&lt;- ## [15] aggregate ## [16] alphabetFrequency ## [17] anyDuplicated ## [18] anyNA ## [19] append ## [20] as.character ## [21] as.complex ## [22] as.data.frame ## [23] as.env ## [24] as.factor ## [25] as.integer ## [26] as.list ## [27] as.logical ## [28] as.matrix ## [29] as.numeric ## [30] as.raw ## [31] as.vector ## [32] bindROWS ## [33] by ## [34] c ## [35] cbind ## [36] chartr ## [37] coerce ## [38] compact ## [39] compareStrings ## [40] complement ## [41] consensusMatrix ## [42] consensusString ## [43] countOverlaps ## [44] countPattern ## [45] countPDict ## [46] dinucleotideFrequencyTest ## [47] do.call ## [48] droplevels ## [49] duplicated ## [50] elementMetadata ## [51] elementMetadata&lt;- ## [52] elementNROWS ## [53] elementType ## [54] eval ## [55] expand ## [56] expand.grid ## [57] extractAt ## [58] extractROWS ## [59] FactorToClass ## [60] Filter ## [61] findOverlaps ## [62] getListElement ## [63] hasOnlyBaseLetters ## [64] head ## [65] ifelse2 ## [66] intersect ## [67] is.na ## [68] is.unsorted ## [69] isEmpty ## [70] isMatchingEndingAt ## [71] isMatchingStartingAt ## [72] lapply ## [73] length ## [74] lengths ## [75] letterFrequency ## [76] make_XStringSet_from_strings ## [77] match ## [78] matchPattern ## [79] matchPDict ## [80] mcols ## [81] mcols&lt;- ## [82] merge ## [83] mergeROWS ## [84] metadata ## [85] metadata&lt;- ## [86] mstack ## [87] names ## [88] names&lt;- ## [89] nchar ## [90] neditEndingAt ## [91] neditStartingAt ## [92] normalizeSingleBracketReplacementValue ## [93] nucleotideFrequencyAt ## [94] oligonucleotideFrequency ## [95] order ## [96] overlapsAny ## [97] PairwiseAlignments ## [98] PairwiseAlignmentsSingleSubject ## [99] palindromeArmLength ## [100] parallel_slot_names ## [101] parallelVectorNames ## [102] pcompare ## [103] pcompareRecursively ## [104] PDict ## [105] PWM ## [106] rank ## [107] rbind ## [108] Reduce ## [109] relist ## [110] relistToClass ## [111] rename ## [112] rep ## [113] rep.int ## [114] replaceAt ## [115] replaceLetterAt ## [116] replaceROWS ## [117] rev ## [118] revElements ## [119] reverse ## [120] reverseComplement ## [121] sapply ## [122] selfmatch ## [123] seqinfo ## [124] seqinfo&lt;- ## [125] seqlevelsInUse ## [126] seqtype ## [127] seqtype&lt;- ## [128] setdiff ## [129] setequal ## [130] setListElement ## [131] shiftApply ## [132] show ## [133] showAsCell ## [134] sort ## [135] split ## [136] split&lt;- ## [137] stack ## [138] stringDist ## [139] strsplit ## [140] subseq ## [141] subseq&lt;- ## [142] subset ## [143] subsetByOverlaps ## [144] summary ## [145] table ## [146] tail ## [147] tapply ## [148] threebands ## [149] toString ## [150] transform ## [151] translate ## [152] trimLRPatterns ## [153] twoWayAlphabetFrequency ## [154] union ## [155] unique ## [156] uniqueLetters ## [157] unlist ## [158] unname ## [159] unsplit ## [160] unstrsplit ## [161] updateObject ## [162] values ## [163] values&lt;- ## [164] vcountPattern ## [165] vcountPDict ## [166] vmatchPattern ## [167] vwhichPDict ## [168] which.isMatchingEndingAt ## [169] which.isMatchingStartingAt ## [170] whichPDict ## [171] width ## [172] window ## [173] window&lt;- ## [174] windows ## [175] with ## [176] within ## [177] xtabs ## [178] xtfrm ## [179] xvcopy ## [180] zipdown ## see &#39;?methods&#39; for accessing help and source code 7.3 Using seqinr Another useful library in sequence analysis is seqinr. After installing the library by invoking install.packages(\"seqinr\") to the console, load it to the workspace library(seqinr) Reading the fasta file containing the protein sequence using the read.fasta function. proseq = read.fasta(file=&quot;data/spike_multifasta.txt&quot;, seqtype=&quot;AA&quot;) str(proseq) ## List of 6 ## $ Spike_SARS_CoV2_2019 : &#39;SeqFastaAA&#39; chr [1:1273] &quot;M&quot; &quot;F&quot; &quot;V&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_SARS_CoV2_2019&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_SARS_CoV2_2019&quot; ## $ Spike_SARS_CoV : &#39;SeqFastaAA&#39; chr [1:1255] &quot;M&quot; &quot;F&quot; &quot;I&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_SARS_CoV&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_SARS_CoV&quot; ## $ Spike_Bat_coronavirus_RaTG13 : &#39;SeqFastaAA&#39; chr [1:1269] &quot;M&quot; &quot;F&quot; &quot;V&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_Bat_coronavirus_RaTG13&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_Bat_coronavirus_RaTG13&quot; ## $ Spike_Pangolin_coronavirus_GX: &#39;SeqFastaAA&#39; chr [1:1269] &quot;M&quot; &quot;F&quot; &quot;V&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_Pangolin_coronavirus_GX&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_Pangolin_coronavirus_GX&quot; ## $ Spike_Pangolin_coronavirus_GD: &#39;SeqFastaAA&#39; chr [1:1265] &quot;M&quot; &quot;L&quot; &quot;F&quot; &quot;F&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_Pangolin_coronavirus_GD&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_Pangolin_coronavirus_GD&quot; ## $ Spike_WIV1_Bat_Coronovirus : &#39;SeqFastaAA&#39; chr [1:1256] &quot;M&quot; &quot;K&quot; &quot;L&quot; &quot;L&quot; ... ## ..- attr(*, &quot;name&quot;)= chr &quot;Spike_WIV1_Bat_Coronovirus&quot; ## ..- attr(*, &quot;Annot&quot;)= chr &quot;&gt;Spike_WIV1_Bat_Coronovirus&quot; Count the number of sequences num_seq = length(proseq) print(paste(&quot;Number of sequences = &quot;, num_seq)) ## [1] &quot;Number of sequences = 6&quot; Names of the sequences names=getName(proseq) names ## [1] &quot;Spike_SARS_CoV2_2019&quot; &quot;Spike_SARS_CoV&quot; ## [3] &quot;Spike_Bat_coronavirus_RaTG13&quot; &quot;Spike_Pangolin_coronavirus_GX&quot; ## [5] &quot;Spike_Pangolin_coronavirus_GD&quot; &quot;Spike_WIV1_Bat_Coronovirus&quot; Annotation of sequences annotation &lt;- getAnnot(proseq) annotation ## [[1]] ## [1] &quot;&gt;Spike_SARS_CoV2_2019&quot; ## ## [[2]] ## [1] &quot;&gt;Spike_SARS_CoV&quot; ## ## [[3]] ## [1] &quot;&gt;Spike_Bat_coronavirus_RaTG13&quot; ## ## [[4]] ## [1] &quot;&gt;Spike_Pangolin_coronavirus_GX&quot; ## ## [[5]] ## [1] &quot;&gt;Spike_Pangolin_coronavirus_GD&quot; ## ## [[6]] ## [1] &quot;&gt;Spike_WIV1_Bat_Coronovirus&quot; Length of individual sequences len_seq = getLength(proseq) len_seq ## [1] 1273 1255 1269 1269 1265 1256 Protein statistics print(AAstat(proseq[[1]])) ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 79 40 62 48 77 82 17 76 61 108 14 88 58 62 42 99 97 97 12 ## Y ## 54 ## ## $Prop ## $Prop$Tiny ## [1] 0.3118617 ## ## $Prop$Small ## [1] 0.5514533 ## ## $Prop$Aliphatic ## [1] 0.2207384 ## ## $Prop$Aromatic ## [1] 0.1256874 ## ## $Prop$Non.polar ## [1] 0.5475255 ## ## $Prop$Polar ## [1] 0.4524745 ## ## $Prop$Charged ## [1] 0.1806756 ## ## $Prop$Basic ## [1] 0.09426551 ## ## $Prop$Acidic ## [1] 0.08641005 ## ## ## $Pi ## [1] 6.236478 It gives the type of proteins for (i in 1:num_seq) { print(names[i]) print(AAstat(proseq[[i]])) } ## [1] &quot;Spike_SARS_CoV2_2019&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 79 40 62 48 77 82 17 76 61 108 14 88 58 62 42 99 97 97 12 ## Y ## 54 ## ## $Prop ## $Prop$Tiny ## [1] 0.3118617 ## ## $Prop$Small ## [1] 0.5514533 ## ## $Prop$Aliphatic ## [1] 0.2207384 ## ## $Prop$Aromatic ## [1] 0.1256874 ## ## $Prop$Non.polar ## [1] 0.5475255 ## ## $Prop$Polar ## [1] 0.4524745 ## ## $Prop$Charged ## [1] 0.1806756 ## ## $Prop$Basic ## [1] 0.09426551 ## ## $Prop$Acidic ## [1] 0.08641005 ## ## ## $Pi ## [1] 6.236478 ## ## [1] &quot;Spike_SARS_CoV&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 84 39 74 42 83 78 15 77 60 99 20 81 57 55 39 96 100 91 11 ## Y ## 54 ## ## $Prop ## $Prop$Tiny ## [1] 0.3163347 ## ## $Prop$Small ## [1] 0.5577689 ## ## $Prop$Aliphatic ## [1] 0.212749 ## ## $Prop$Aromatic ## [1] 0.1298805 ## ## $Prop$Non.polar ## [1] 0.5521912 ## ## $Prop$Polar ## [1] 0.4478088 ## ## $Prop$Charged ## [1] 0.1832669 ## ## $Prop$Basic ## [1] 0.09083665 ## ## $Prop$Acidic ## [1] 0.09243028 ## ## ## $Pi ## [1] 5.510607 ## ## [1] &quot;Spike_Bat_coronavirus_RaTG13&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 80 40 64 47 75 82 18 79 63 109 14 85 58 60 39 97 98 94 12 ## Y ## 55 ## ## $Prop ## $Prop$Tiny ## [1] 0.3128448 ## ## $Prop$Small ## [1] 0.5500394 ## ## $Prop$Aliphatic ## [1] 0.2222222 ## ## $Prop$Aromatic ## [1] 0.1260835 ## ## $Prop$Non.polar ## [1] 0.5500394 ## ## $Prop$Polar ## [1] 0.4499606 ## ## $Prop$Charged ## [1] 0.1820331 ## ## $Prop$Basic ## [1] 0.09456265 ## ## $Prop$Acidic ## [1] 0.08747045 ## ## ## $Pi ## [1] 6.11311 ## ## [1] &quot;Spike_Pangolin_coronavirus_GX&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 76 40 61 48 75 85 17 79 61 113 15 82 56 62 41 94 98 97 12 ## Y ## 55 ## ## $Prop ## $Prop$Tiny ## [1] 0.3096927 ## ## $Prop$Small ## [1] 0.5429472 ## ## $Prop$Aliphatic ## [1] 0.2277384 ## ## $Prop$Aromatic ## [1] 0.1252955 ## ## $Prop$Non.polar ## [1] 0.5539795 ## ## $Prop$Polar ## [1] 0.4444444 ## ## $Prop$Charged ## [1] 0.179669 ## ## $Prop$Basic ## [1] 0.09377463 ## ## $Prop$Acidic ## [1] 0.08589441 ## ## ## $Pi ## [1] 6.235931 ## ## [1] &quot;Spike_Pangolin_coronavirus_GD&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 82 40 60 48 76 81 14 80 58 103 15 90 54 58 40 100 99 95 12 ## Y ## 60 ## ## $Prop ## $Prop$Tiny ## [1] 0.3177866 ## ## $Prop$Small ## [1] 0.5541502 ## ## $Prop$Aliphatic ## [1] 0.2197628 ## ## $Prop$Aromatic ## [1] 0.1280632 ## ## $Prop$Non.polar ## [1] 0.5517787 ## ## $Prop$Polar ## [1] 0.4482213 ## ## $Prop$Charged ## [1] 0.173913 ## ## $Prop$Basic ## [1] 0.08853755 ## ## $Prop$Acidic ## [1] 0.08537549 ## ## ## $Pi ## [1] 5.900948 ## ## [1] &quot;Spike_WIV1_Bat_Coronovirus&quot; ## $Compo ## ## * A C D E F G H I K L M N P Q R S T V W ## 0 82 39 72 43 83 77 15 77 60 102 17 86 62 54 42 98 93 93 11 ## Y ## 50 ## ## $Prop ## $Prop$Tiny ## [1] 0.3097134 ## ## $Prop$Small ## [1] 0.5589172 ## ## $Prop$Aliphatic ## [1] 0.2165605 ## ## $Prop$Aromatic ## [1] 0.1265924 ## ## $Prop$Non.polar ## [1] 0.5517516 ## ## $Prop$Polar ## [1] 0.4482484 ## ## $Prop$Charged ## [1] 0.1847134 ## ## $Prop$Basic ## [1] 0.09315287 ## ## $Prop$Acidic ## [1] 0.09156051 ## ## ## $Pi ## [1] 5.739146 Show commands in seqinr lseqinr() ## [1] &quot;a&quot; &quot;aaa&quot; ## [3] &quot;AAstat&quot; &quot;acnucclose&quot; ## [5] &quot;acnucopen&quot; &quot;al2bp&quot; ## [7] &quot;alllistranks&quot; &quot;alr&quot; ## [9] &quot;amb&quot; &quot;as.alignment&quot; ## [11] &quot;as.matrix.alignment&quot; &quot;as.SeqAcnucWeb&quot; ## [13] &quot;as.SeqFastaAA&quot; &quot;as.SeqFastadna&quot; ## [15] &quot;as.SeqFrag&quot; &quot;autosocket&quot; ## [17] &quot;baselineabif&quot; &quot;bma&quot; ## [19] &quot;c2s&quot; &quot;cai&quot; ## [21] &quot;cfl&quot; &quot;choosebank&quot; ## [23] &quot;circle&quot; &quot;clfcd&quot; ## [25] &quot;clientid&quot; &quot;closebank&quot; ## [27] &quot;col2alpha&quot; &quot;comp&quot; ## [29] &quot;computePI&quot; &quot;con&quot; ## [31] &quot;consensus&quot; &quot;count&quot; ## [33] &quot;countfreelists&quot; &quot;countsubseqs&quot; ## [35] &quot;crelistfromclientdata&quot; &quot;css&quot; ## [37] &quot;dia.bactgensize&quot; &quot;dia.db.growth&quot; ## [39] &quot;dist.alignment&quot; &quot;dotchart.uco&quot; ## [41] &quot;dotPlot&quot; &quot;draw.oriloc&quot; ## [43] &quot;draw.rearranged.oriloc&quot; &quot;draw.recstat&quot; ## [45] &quot;exseq&quot; &quot;extract.breakpoints&quot; ## [47] &quot;extractseqs&quot; &quot;fastacc&quot; ## [49] &quot;gb2fasta&quot; &quot;gbk2g2&quot; ## [51] &quot;gbk2g2.euk&quot; &quot;GC&quot; ## [53] &quot;GC1&quot; &quot;GC2&quot; ## [55] &quot;GC3&quot; &quot;GCpos&quot; ## [57] &quot;get.db.growth&quot; &quot;getAnnot&quot; ## [59] &quot;getAnnot.default&quot; &quot;getAnnot.list&quot; ## [61] &quot;getAnnot.logical&quot; &quot;getAnnot.qaw&quot; ## [63] &quot;getAnnot.SeqAcnucWeb&quot; &quot;getAnnot.SeqFastaAA&quot; ## [65] &quot;getAnnot.SeqFastadna&quot; &quot;getAttributsocket&quot; ## [67] &quot;getFrag&quot; &quot;getFrag.character&quot; ## [69] &quot;getFrag.default&quot; &quot;getFrag.list&quot; ## [71] &quot;getFrag.logical&quot; &quot;getFrag.qaw&quot; ## [73] &quot;getFrag.SeqAcnucWeb&quot; &quot;getFrag.SeqFastaAA&quot; ## [75] &quot;getFrag.SeqFastadna&quot; &quot;getFrag.SeqFrag&quot; ## [77] &quot;getKeyword&quot; &quot;getKeyword.default&quot; ## [79] &quot;getKeyword.list&quot; &quot;getKeyword.logical&quot; ## [81] &quot;getKeyword.qaw&quot; &quot;getKeyword.SeqAcnucWeb&quot; ## [83] &quot;getLength&quot; &quot;getLength.character&quot; ## [85] &quot;getLength.default&quot; &quot;getLength.list&quot; ## [87] &quot;getLength.logical&quot; &quot;getLength.qaw&quot; ## [89] &quot;getLength.SeqAcnucWeb&quot; &quot;getLength.SeqFastaAA&quot; ## [91] &quot;getLength.SeqFastadna&quot; &quot;getLength.SeqFrag&quot; ## [93] &quot;getlistrank&quot; &quot;getliststate&quot; ## [95] &quot;getLocation&quot; &quot;getLocation.default&quot; ## [97] &quot;getLocation.list&quot; &quot;getLocation.logical&quot; ## [99] &quot;getLocation.qaw&quot; &quot;getLocation.SeqAcnucWeb&quot; ## [101] &quot;getName&quot; &quot;getName.default&quot; ## [103] &quot;getName.list&quot; &quot;getName.logical&quot; ## [105] &quot;getName.qaw&quot; &quot;getName.SeqAcnucWeb&quot; ## [107] &quot;getName.SeqFastaAA&quot; &quot;getName.SeqFastadna&quot; ## [109] &quot;getName.SeqFrag&quot; &quot;getNumber.socket&quot; ## [111] &quot;getSequence&quot; &quot;getSequence.character&quot; ## [113] &quot;getSequence.default&quot; &quot;getSequence.list&quot; ## [115] &quot;getSequence.logical&quot; &quot;getSequence.qaw&quot; ## [117] &quot;getSequence.SeqAcnucWeb&quot; &quot;getSequence.SeqFastaAA&quot; ## [119] &quot;getSequence.SeqFastadna&quot; &quot;getSequence.SeqFrag&quot; ## [121] &quot;getTrans&quot; &quot;getTrans.character&quot; ## [123] &quot;getTrans.default&quot; &quot;getTrans.list&quot; ## [125] &quot;getTrans.logical&quot; &quot;getTrans.qaw&quot; ## [127] &quot;getTrans.SeqAcnucWeb&quot; &quot;getTrans.SeqFastadna&quot; ## [129] &quot;getTrans.SeqFrag&quot; &quot;getType&quot; ## [131] &quot;gfrag&quot; &quot;ghelp&quot; ## [133] &quot;gln&quot; &quot;glr&quot; ## [135] &quot;gls&quot; &quot;is.SeqAcnucWeb&quot; ## [137] &quot;is.SeqFastaAA&quot; &quot;is.SeqFastadna&quot; ## [139] &quot;is.SeqFrag&quot; &quot;isenum&quot; ## [141] &quot;isn&quot; &quot;kaks&quot; ## [143] &quot;kdb&quot; &quot;knowndbs&quot; ## [145] &quot;lseqinr&quot; &quot;modifylist&quot; ## [147] &quot;move&quot; &quot;mv&quot; ## [149] &quot;n2s&quot; &quot;oriloc&quot; ## [151] &quot;parser.socket&quot; &quot;peakabif&quot; ## [153] &quot;permutation&quot; &quot;pga&quot; ## [155] &quot;plot.SeqAcnucWeb&quot; &quot;plotabif&quot; ## [157] &quot;plotladder&quot; &quot;plotPanels&quot; ## [159] &quot;pmw&quot; &quot;prepgetannots&quot; ## [161] &quot;prettyseq&quot; &quot;print.qaw&quot; ## [163] &quot;print.SeqAcnucWeb&quot; &quot;query&quot; ## [165] &quot;quitacnuc&quot; &quot;read.abif&quot; ## [167] &quot;read.alignment&quot; &quot;read.fasta&quot; ## [169] &quot;readBins&quot; &quot;readfirstrec&quot; ## [171] &quot;readPanels&quot; &quot;readsmj&quot; ## [173] &quot;rearranged.oriloc&quot; &quot;recstat&quot; ## [175] &quot;residuecount&quot; &quot;reverse.align&quot; ## [177] &quot;rho&quot; &quot;rot13&quot; ## [179] &quot;s2c&quot; &quot;s2n&quot; ## [181] &quot;savelist&quot; &quot;SEQINR.UTIL&quot; ## [183] &quot;setlistname&quot; &quot;splitseq&quot; ## [185] &quot;stresc&quot; &quot;stutterabif&quot; ## [187] &quot;summary.SeqFastaAA&quot; &quot;summary.SeqFastadna&quot; ## [189] &quot;swap&quot; &quot;syncodons&quot; ## [191] &quot;synsequence&quot; &quot;tablecode&quot; ## [193] &quot;test.co.recstat&quot; &quot;test.li.recstat&quot; ## [195] &quot;translate&quot; &quot;trimSpace&quot; ## [197] &quot;uco&quot; &quot;ucoweight&quot; ## [199] &quot;where.is.this.acc&quot; &quot;words&quot; ## [201] &quot;words.pos&quot; &quot;write.fasta&quot; ## [203] &quot;zscore&quot; 7.4 Using Short Read This library can be installed by invoking the BiocManager::install(\"ShortRead\") command to the console. load the library library(ShortRead) Reading the fastq sequences fq = readFastq(&quot;data/file2.fastq&quot;) fq ## class: ShortReadQ ## length: 5 reads; width: 149..166 cycles Preview of first 3 sequences fq[1:3] ## class: ShortReadQ ## length: 3 reads; width: 149 161 cycles Sequence information sread(fq) ## DNAStringSet object of length 5: ## width seq ## [1] 149 CGCAAGCGAGTTAAGCAGTCTGTCCAAAGCATGT...TTATCCACATCTGTCATGACGATTTCGTTTGAT ## [2] 161 CGTTATCAGAGAGCTCTTGTCGCAAGCGAGTTAA...CTACCAAGTTATCCACATCTGTCATGACGATTT ## [3] 161 AGCGAGTTAAGCAGTCTGTCCAAAGCATGTGTAT...GACGATTTCGTTTGATTTTGCCTTAAAAAGAAA ## [4] 166 GACCCCTTCTCATCAGGAAGGGTTAATCTTTAAA...TGGATTCGCCCTTTAGTAGCTGAAGAAGTAGAG ## [5] 166 CCCCTTCTCATCAGGAAGGGTTAATCTTTAAATG...GATTCGCCCTTTAGTAGCTGAAGAAGTAGAGGG Subset the sequence from second to fifth sread(fq[2:5]) ## DNAStringSet object of length 4: ## width seq ## [1] 161 CGTTATCAGAGAGCTCTTGTCGCAAGCGAGTTAA...CTACCAAGTTATCCACATCTGTCATGACGATTT ## [2] 161 AGCGAGTTAAGCAGTCTGTCCAAAGCATGTGTAT...GACGATTTCGTTTGATTTTGCCTTAAAAAGAAA ## [3] 166 GACCCCTTCTCATCAGGAAGGGTTAATCTTTAAA...TGGATTCGCCCTTTAGTAGCTGAAGAAGTAGAG ## [4] 166 CCCCTTCTCATCAGGAAGGGTTAATCTTTAAATG...GATTCGCCCTTTAGTAGCTGAAGAAGTAGAGGG Inspect the quality of the sequence quality(fq) ## class: FastqQuality ## quality: ## BStringSet object of length 5: ## width seq ## [1] 149 CCCC&gt;CHDBBC&lt;=8=DCCCDDDCB&gt;BG?GGEDB=...C@B==8=CDDDDDDDDDC==&lt;C@C8&lt;&lt;DD=BCE ## [2] 161 &lt;CE:@C=&lt;&lt;=DDDCBBC&gt;&lt;&lt;&lt;CDD&gt;BCEHGI&gt;C&gt;...999929-39:&gt;BE&gt;BBA@ADEC?&gt;?AAA999C; ## [3] 161 DDEDEEEAE@DD=&gt;=:==BB?BG&gt;FDEDCCBBBB...D&gt;///99*//::4:&lt;BBB6BD-2--555-5::: ## [4] 166 CCCLL;E@DE&gt;&gt;=DDDAE@EEBE@@?CCEE?EE?...BB@DDAD8884;C&lt;CFGGE?@?C?CC=BDEEEA ## [5] 166 666/6:::=BBCCBACADD6@:D@DDEE&gt;DD&gt;DE...&gt;BDAC58;6:D&gt;DDDDGEEBB&lt;CD@DDDEEED&gt; Number of sequence in the file length(fq) ## [1] 5 Length of reads readLength = width(fq) readLength ## [1] 149 161 161 166 166 generating the summary of fasta sequences fq_reads = sread(fq) id_of_reads=id(fq) id_of_reads[1:5] ## BStringSet object of length 5: ## width seq ## [1] 17 OLVOG:01110:02677 ## [2] 17 OLVOG:01219:01823 ## [3] 17 OLVOG:01240:02825 ## [4] 17 OLVOG:02464:02160 ## [5] 17 OLVOG:02703:02334 fq_reads ## DNAStringSet object of length 5: ## width seq ## [1] 149 CGCAAGCGAGTTAAGCAGTCTGTCCAAAGCATGT...TTATCCACATCTGTCATGACGATTTCGTTTGAT ## [2] 161 CGTTATCAGAGAGCTCTTGTCGCAAGCGAGTTAA...CTACCAAGTTATCCACATCTGTCATGACGATTT ## [3] 161 AGCGAGTTAAGCAGTCTGTCCAAAGCATGTGTAT...GACGATTTCGTTTGATTTTGCCTTAAAAAGAAA ## [4] 166 GACCCCTTCTCATCAGGAAGGGTTAATCTTTAAA...TGGATTCGCCCTTTAGTAGCTGAAGAAGTAGAG ## [5] 166 CCCCTTCTCATCAGGAAGGGTTAATCTTTAAATG...GATTCGCCCTTTAGTAGCTGAAGAAGTAGAGGG Seq length - we can generate the sequence lenght by converting it to a dataframe seq_length = as.data.frame(fq_reads@ranges@width) seq_length ## fq_reads@ranges@width ## 1 149 ## 2 161 ## 3 161 ## 4 166 ## 5 166 Quality scores quality_scores=quality(fq) quality_scores[1:5] ## class: FastqQuality ## quality: ## BStringSet object of length 5: ## width seq ## [1] 149 CCCC&gt;CHDBBC&lt;=8=DCCCDDDCB&gt;BG?GGEDB=...C@B==8=CDDDDDDDDDC==&lt;C@C8&lt;&lt;DD=BCE ## [2] 161 &lt;CE:@C=&lt;&lt;=DDDCBBC&gt;&lt;&lt;&lt;CDD&gt;BCEHGI&gt;C&gt;...999929-39:&gt;BE&gt;BBA@ADEC?&gt;?AAA999C; ## [3] 161 DDEDEEEAE@DD=&gt;=:==BB?BG&gt;FDEDCCBBBB...D&gt;///99*//::4:&lt;BBB6BD-2--555-5::: ## [4] 166 CCCLL;E@DE&gt;&gt;=DDDAE@EEBE@@?CCEE?EE?...BB@DDAD8884;C&lt;CFGGE?@?C?CC=BDEEEA ## [5] 166 666/6:::=BBCCBACADD6@:D@DDEE&gt;DD&gt;DE...&gt;BDAC58;6:D&gt;DDDDGEEBB&lt;CD@DDDEEED&gt; Convert the scores to matrix and see as real numbers scores=as(quality_scores, &quot;matrix&quot;) scores ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] ## [1,] 34 34 34 34 29 34 39 35 33 33 34 27 28 23 ## [2,] 27 34 36 25 31 34 28 27 27 28 35 35 35 34 ## [3,] 35 35 36 35 36 36 36 32 36 31 35 35 28 29 ## [4,] 34 34 34 43 43 26 36 31 35 36 29 29 28 35 ## [5,] 21 21 21 14 21 25 25 25 28 33 33 34 34 33 ## [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] ## [1,] 28 35 34 34 34 35 35 35 34 33 29 33 ## [2,] 33 33 34 29 27 27 27 34 35 35 29 33 ## [3,] 28 25 28 28 33 33 30 33 38 29 37 35 ## [4,] 35 35 32 36 31 36 36 33 36 31 31 30 ## [5,] 32 34 32 35 35 21 31 25 35 31 35 35 ## [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] ## [1,] 38 30 38 38 36 35 33 28 28 28 35 36 ## [2,] 34 36 39 38 40 29 34 29 34 37 28 28 ## [3,] 36 35 34 34 33 33 33 33 33 34 33 25 ## [4,] 34 34 36 36 30 36 36 30 35 35 27 27 ## [5,] 36 36 29 35 35 29 35 36 35 35 36 30 ## [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50] ## [1,] 38 38 38 26 37 34 34 34 34 34 33 34 ## [2,] 29 35 34 34 32 34 23 28 28 25 28 35 ## [3,] 33 35 35 35 35 35 35 34 34 28 28 28 ## [4,] 21 16 25 30 25 30 33 30 34 40 37 26 ## [5,] 36 36 32 36 36 31 36 36 36 26 35 36 ## [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62] ## [1,] 34 30 33 33 33 25 33 36 30 37 31 35 ## [2,] 35 36 36 34 33 33 33 33 33 33 33 25 ## [3,] 28 21 26 34 23 32 26 23 23 18 14 25 ## [4,] 33 30 30 36 36 36 36 27 20 27 35 36 ## [5,] 36 36 35 35 35 28 28 28 35 35 35 26 ## [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74] ## [1,] 35 36 30 35 35 28 27 27 23 27 35 28 ## [2,] 33 30 30 27 28 27 25 25 34 25 25 25 ## [3,] 33 25 25 25 14 15 28 21 28 27 28 21 ## [4,] 36 26 35 33 34 34 35 36 35 35 35 36 ## [5,] 35 34 35 35 35 36 35 35 35 37 36 36 ## [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86] ## [1,] 35 35 35 26 32 19 25 18 25 23 29 26 ## [2,] 25 14 25 25 14 25 26 32 32 36 30 34 ## [3,] 27 9 13 9 12 16 20 8 24 25 35 35 ## [4,] 35 35 30 36 32 35 35 35 35 35 35 35 ## [5,] 29 36 32 35 35 35 34 35 34 36 35 35 ## [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98] ## [1,] 34 35 36 37 33 33 33 34 32 37 40 38 ## [2,] 34 31 30 29 14 25 25 14 25 34 34 32 ## [3,] 35 35 34 35 29 34 34 33 19 31 31 24 ## [4,] 35 35 35 30 34 31 35 35 35 35 35 35 ## [5,] 35 30 34 31 35 35 35 35 34 34 31 36 ## [,99] [,100] [,101] [,102] [,103] [,104] [,105] [,106] [,107] [,108] ## [1,] 26 34 34 35 35 30 34 35 26 32 ## [2,] 34 17 24 24 13 24 17 24 28 34 ## [3,] 18 12 18 18 12 17 23 17 17 12 ## [4,] 32 36 35 35 35 34 34 30 34 36 ## [5,] 35 35 36 35 36 28 33 33 33 33 ## [,109] [,110] [,111] [,112] [,113] [,114] [,115] [,116] [,117] [,118] ## [1,] 32 25 25 25 23 28 33 35 34 31 ## [2,] 33 32 33 36 36 35 36 23 26 26 ## [3,] 17 16 23 23 25 32 33 33 26 21 ## [4,] 35 35 35 35 35 32 33 33 35 35 ## [5,] 34 32 32 32 34 34 34 35 35 28 ## [,119] [,120] [,121] [,122] [,123] [,124] [,125] [,126] [,127] [,128] ## [1,] 33 28 28 23 28 34 35 35 35 35 ## [2,] 26 12 24 31 30 29 24 30 29 23 ## [3,] 21 24 32 35 36 33 33 33 33 33 ## [4,] 35 30 34 34 35 35 35 35 29 36 ## [5,] 32 33 35 33 33 33 28 33 35 35 ## [,129] [,130] [,131] [,132] [,133] [,134] [,135] [,136] [,137] [,138] ## [1,] 35 35 35 35 35 34 28 28 27 34 ## [2,] 24 24 24 24 17 24 12 18 24 25 ## [3,] 35 29 14 14 14 24 24 9 14 14 ## [4,] 35 35 34 34 33 33 33 31 35 35 ## [5,] 35 35 35 33 33 29 33 35 32 34 ## [,139] [,140] [,141] [,142] [,143] [,144] [,145] [,146] [,147] [,148] ## [1,] 31 34 23 27 27 35 35 28 33 34 ## [2,] 29 33 36 29 33 33 32 31 32 35 ## [3,] 25 25 19 25 27 33 33 33 21 33 ## [4,] 32 35 23 23 23 19 26 34 27 34 ## [5,] 20 23 26 21 25 35 29 35 35 35 ## [,149] [,150] [,151] [,152] [,153] [,154] [,155] [,156] [,157] [,158] ## [1,] 36 NA NA NA NA NA NA NA NA NA ## [2,] 36 34 30 29 30 32 32 32 24 24 ## [3,] 35 12 17 12 12 20 20 20 12 20 ## [4,] 37 38 38 36 30 31 30 34 30 34 ## [5,] 35 38 36 36 33 33 27 34 35 31 ## [,159] [,160] [,161] [,162] [,163] [,164] [,165] [,166] ## [1,] NA NA NA NA NA NA NA NA ## [2,] 24 34 26 NA NA NA NA NA ## [3,] 25 25 25 NA NA NA NA NA ## [4,] 34 28 33 35 36 36 36 32 ## [5,] 35 35 35 36 36 36 35 29 Mean score for each sequence mean_score_for_each_sequence = rowMeans(scores, na.rm=TRUE) mean_score_for_each_sequence ## [1] 32.00000 29.18012 26.57764 32.99398 32.71084 Mean score for each position mean_score_for_each_position = rowMeans(scores, na.rm=TRUE) mean_score_for_each_position ## [1] 32.00000 29.18012 26.57764 32.99398 32.71084 Plot a boxplot for the scores boxplot(scores, xlab=&quot;Position&quot;, ylab=&quot;Phred score&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
